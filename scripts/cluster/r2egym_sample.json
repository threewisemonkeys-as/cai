{"repo_name": "aiohttp", "docker_image": "namanjain12/aiohttp_final:f0d74880deec8fcd982bce639c93c5e130d41198", "commit_hash": "f0d74880deec8fcd982bce639c93c5e130d41198", "parsed_commit_content": "{\n    \"file_diffs\": [\n        {\n            \"old_file_content\": \"0.18.0 (19-10-2015)\\n-------------------\\n\\n- Use errors.HttpProcessingError.message as HTTP error reason and\\n  message #459\\n\\n- Optimize cythonized multidict a bit\\n\\n- Change repr's of multidicts and multidict views\\n\\n- default headers in ClientSession are now case-insensitive\\n\\n- Make '=' char and 'wss://' schema safe in urls #477\\n\\n- `ClientResponse.close()` forces connection closing by default from now #479\\n\\n  N.B. Backward incompatible change: was `.close(force=False) Using\\n  `force` parameter for the method is deprecated: use `.release()`\\n  instead.\\n\\n- Properly requote URL's path #480\\n\\n- add `skip_auto_headers` parameter for client API #486\\n\\n- Properly parse URL path in aiohttp.web.Request #489\\n\\n- Raise RuntimeError when chunked enabled and HTTP is 1.0 #488\\n\\n- Fix a bug with processing io.BytesIO as data parameter for client API #500\\n\\n- Skip auto-generation of Content-Type header #507\\n\\n- Use sendfile facility for static file handling #503\\n\\n- Default `response_factory` in `app.router.add_static` now is\\n  `StreamResponse`, not `None`. The functionality is not changed if\\n  default is not specified.\\n\\n- Drop `ClientResponse.message` attribute, it was always implementation detail.\\n\\n- Streams are optimized for speed and mostly memory in case of a big\\n  HTTP message sizes #496\\n\\n- Fix a bug for server-side cookies for dropping cookie and setting it\\n  again without Max-Age parameter.\\n\\n- Don't trim redirect URL in client API #499\\n\\n- Extend precision of access log \\\"D\\\" to milliseconds #527\\n\\n- Deprecate `StreamResponse.start()` method in favor of\\n  `StreamResponse.prepare()` coroutine #525\\n\\n  `.start()` is still supported but responses begun with `.start()`\\n  doesn't call signal for response preparing to be sent.\\n\\n- Add `StreamReader.__repr__`\\n\\n- Drop Python 3.3 support, from now minimal required version is Python\\n  3.4.1 #541\\n\\n- Add `async with` support for `ClientSession.request()` and family #536\\n\\n- Ignore message body on 204 and 304 responses #505\\n\\n- `TCPConnector` processed both IPv4 and IPv6 by default #559\\n\\n- Add `.routes()` view for urldispatcher #519\\n\\n- Route name should be a valid identifier name from now #567\\n\\n- Implement server signals #562\\n\\n- Drop an year-old deprecated *files* parameter from client API.\\n\\n- Added `async for` support for aiohttp stream #542\\n\\n0.17.4 (09-29-2015)\\n-------------------\\n\\n- Properly parse URL path in aiohttp.web.Request #489\\n\\n- Add missing coroutine decorator, the client api is await-compatible now\\n\\n0.17.3 (08-28-2015)\\n---------------------\\n\\n- Remove Content-Length header on compressed responses #450\\n\\n- Support Python 3.5\\n\\n- Improve performance of transport in-use list #472\\n\\n- Fix connection pooling #473\\n\\n0.17.2 (08-11-2015)\\n---------------------\\n\\n- Don't forget to pass `data` argument forward #462\\n\\n- Fix multipart read bytes count #463\\n\\n0.17.1 (08-10-2015)\\n---------------------\\n\\n- Fix multidict comparsion to arbitrary abc.Mapping\\n\\n0.17.0 (08-04-2015)\\n---------------------\\n\\n- Make StaticRoute support Last-Modified and If-Modified-Since headers #386\\n\\n- Add Request.if_modified_since and Stream.Response.last_modified properties\\n\\n- Fix deflate compression when writing a chunked response #395\\n\\n- Request`s content-length header is cleared now after redirect from\\n  POST method #391\\n\\n- Return a 400 if server received a non HTTP content #405\\n\\n- Fix keep-alive support for aiohttp clients #406\\n\\n- Allow gzip compression in high-level server response interface #403\\n\\n- Rename TCPConnector.resolve and family to dns_cache #415\\n\\n- Make UrlDispatcher ignore quoted characters during url matching #414\\n  Backward-compatibility warning: this may change the url matched by\\n  your queries if they send quoted character (like %2F for /) #414\\n\\n- Use optional cchardet accelerator if present #418\\n\\n- Borrow loop from Connector in ClientSession if loop is not set\\n\\n- Add context manager support to ClientSession for session closing.\\n\\n- Add toplevel get(), post(), put(), head(), delete(), options(),\\n  patch() coroutines.\\n\\n- Fix IPv6 support for client API #425\\n\\n- Pass SSL context through proxy connector #421\\n\\n- Make the rule: path for add_route should start with slash\\n\\n- Don't process request finishing by low-level server on closed event loop\\n\\n- Don't override data if multiple files are uploaded with same key #433\\n\\n- Ensure multipart.BodyPartReader.read_chunk read all the necessary data\\n  to avoid false assertions about malformed multipart payload\\n\\n- Dont sent body for 204, 205 and 304 http exceptions #442\\n\\n- Correctly skip Cython compilation in MSVC not found #453\\n\\n- Add response factory to StaticRoute #456\\n\\n- Don't append trailing CRLF for multipart.BodyPartReader #454\\n\\n\\n0.16.6 (07-15-2015)\\n-------------------\\n\\n- Skip compilation on Windows if vcvarsall.bat cannot be found #438\\n\\n0.16.5 (06-13-2015)\\n-------------------\\n\\n- Get rid of all comprehensions and yielding in _multidict #410\\n\\n\\n0.16.4 (06-13-2015)\\n-------------------\\n\\n- Don't clear current exception in multidict's `__repr__` (cythonized\\n  versions) #410\\n\\n\\n0.16.3 (05-30-2015)\\n-------------------\\n\\n- Fix StaticRoute vulnerability to directory traversal attacks #380\\n\\n\\n0.16.2 (05-27-2015)\\n-------------------\\n\\n- Update python version required for `__del__` usage: it's actually\\n  3.4.1 instead of 3.4.0\\n\\n- Add check for presence of loop.is_closed() method before call the\\n  former #378\\n\\n\\n0.16.1 (05-27-2015)\\n-------------------\\n\\n- Fix regression in static file handling #377\\n\\n0.16.0 (05-26-2015)\\n-------------------\\n\\n- Unset waiter future after cancellation #363\\n\\n- Update request url with query parameters #372\\n\\n- Support new `fingerprint` param of TCPConnector to enable verifying\\n  SSL certificates via MD5, SHA1, or SHA256 digest #366\\n\\n- Setup uploaded filename if field value is binary and transfer\\n  encoding is not specified #349\\n\\n- Implement `ClientSession.close()` method\\n\\n- Implement `connector.closed` readonly property\\n\\n- Implement `ClientSession.closed` readonly property\\n\\n- Implement `ClientSession.connector` readonly property\\n\\n- Implement `ClientSession.detach` method\\n\\n- Add `__del__` to client-side objects: sessions, connectors,\\n  connections, requests, responses.\\n\\n- Refactor connections cleanup by connector #357\\n\\n- Add `limit` parameter to connector constructor #358\\n\\n- Add `request.has_body` property #364\\n\\n- Add `response_class` parameter to `ws_connect()` #367\\n\\n- `ProxyConnector` doesn't support keep-alive requests by default\\n  starting from now #368\\n\\n- Add `connector.force_close` property\\n\\n- Add ws_connect to ClientSession #374\\n\\n- Support optional `chunk_size` parameter in `router.add_static()`\\n\\n\\n0.15.3 (04-22-2015)\\n-------------------\\n\\n- Fix graceful shutdown handling\\n\\n- Fix `Expect` header handling for not found and not allowed routes #340\\n\\n\\n0.15.2 (04-19-2015)\\n-------------------\\n\\n- Flow control subsystem refactoring\\n\\n- HTTP server performace optimizations\\n\\n- Allow to match any request method with `*`\\n\\n- Explicitly call drain on transport #316\\n\\n- Make chardet module dependency mandatory #318\\n\\n- Support keep-alive for HTTP 1.0 #325\\n\\n- Do not chunk single file during upload #327\\n\\n- Add ClientSession object for cookie storage and default headers #328\\n\\n- Add `keep_alive_on` argument for HTTP server handler.\\n\\n\\n0.15.1 (03-31-2015)\\n-------------------\\n\\n- Pass Autobahn Testsuit tests\\n\\n- Fixed websocket fragmentation\\n\\n- Fixed websocket close procedure\\n\\n- Fixed parser buffer limits\\n\\n- Added `timeout` parameter to WebSocketResponse ctor\\n\\n- Added `WebSocketResponse.close_code` attribute\\n\\n\\n0.15.0 (03-27-2015)\\n-------------------\\n\\n- Client WebSockets support\\n\\n- New Multipart system #273\\n\\n- Support for \\\"Except\\\" header #287 #267\\n\\n- Set default Content-Type for post requests #184\\n\\n- Fix issue with construction dynamic route with regexps and trailing slash #266\\n\\n- Add repr to web.Request\\n\\n- Add repr to web.Response\\n\\n- Add repr for NotFound and NotAllowed match infos\\n\\n- Add repr for web.Application\\n\\n- Add repr to UrlMappingMatchInfo #217\\n\\n- Gunicorn 19.2.x compatibility\\n\\n\\n0.14.4 (01-29-2015)\\n-------------------\\n\\n- Fix issue with error during constructing of url with regex parts #264\\n\\n\\n0.14.3 (01-28-2015)\\n-------------------\\n\\n- Use path='/' by default for cookies #261\\n\\n\\n0.14.2 (01-23-2015)\\n-------------------\\n\\n- Connections leak in BaseConnector #253\\n\\n- Do not swallow websocket reader exceptions #255\\n\\n- web.Request's read, text, json are memorized #250\\n\\n\\n0.14.1 (01-15-2015)\\n-------------------\\n\\n- HttpMessage._add_default_headers does not overwrite existing headers #216\\n\\n- Expose multidict classes at package level\\n\\n- add `aiohttp.web.WebSocketResponse`\\n\\n- According to RFC 6455 websocket subprotocol preference order is\\n  provided by client, not by server\\n\\n- websocket's ping and pong accept optional message parameter\\n\\n- multidict views do not accept `getall` parameter anymore, it\\n  returns the full body anyway.\\n\\n- multidicts have optional Cython optimization, cythonized version of\\n  multidicts is about 5 times faster than pure Python.\\n\\n- multidict.getall() returns `list`, not `tuple`.\\n\\n- Backward imcompatible change: now there are two mutable multidicts\\n  (`MultiDict`, `CIMultiDict`) and two immutable multidict proxies\\n  (`MultiDictProxy` and `CIMultiDictProxy`). Previous edition of\\n  multidicts was not a part of public API BTW.\\n\\n- Router refactoring to push Not Allowed and Not Found in middleware processing\\n\\n- Convert `ConnectionError` to `aiohttp.DisconnectedError` and don't\\n  eat `ConnectionError` exceptions from web handlers.\\n\\n- Remove hop headers from Response class, wsgi response still uses hop headers.\\n\\n- Allow to send raw chunked encoded response.\\n\\n- Allow to encode output bytes stream into chunked encoding.\\n\\n- Allow to compress output bytes stream with `deflate` encoding.\\n\\n- Server has 75 seconds keepalive timeout now, was non-keepalive by default.\\n\\n- Application doesn't accept `**kwargs` anymore (#243).\\n\\n- Request is inherited from dict now for making per-request storage to\\n  middlewares (#242).\\n\\n\\n0.13.1 (12-31-2014)\\n--------------------\\n\\n- Add `aiohttp.web.StreamResponse.started` property #213\\n\\n- Html escape traceback text in `ServerHttpProtocol.handle_error`\\n\\n- Mention handler and middlewares in `aiohttp.web.RequestHandler.handle_request`\\n  on error (#218)\\n\\n\\n0.13.0 (12-29-2014)\\n-------------------\\n\\n- `StreamResponse.charset` converts value to lower-case on assigning.\\n\\n- Chain exceptions when raise `ClientRequestError`.\\n\\n- Support custom regexps in route variables #204\\n\\n- Fixed graceful shutdown, disable keep-alive on connection closing.\\n\\n- Decode HTTP message with `utf-8` encoding, some servers send headers\\n  in utf-8 encoding #207\\n\\n- Support `aiohtt.web` middlewares #209\\n\\n- Add ssl_context to TCPConnector #206\\n\\n\\n0.12.0 (12-12-2014)\\n-------------------\\n\\n- Deep refactoring of `aiohttp.web` in backward-incompatible manner.\\n  Sorry, we have to do this.\\n\\n- Automatically force aiohttp.web handlers to coroutines in\\n  `UrlDispatcher.add_route()` #186\\n\\n- Rename `Request.POST()` function to `Request.post()`\\n\\n- Added POST attribute\\n\\n- Response processing refactoring: constructor does't accept Request\\n  instance anymore.\\n\\n- Pass application instance to finish callback\\n\\n- Exceptions refactoring\\n\\n- Do not unquote query string in `aiohttp.web.Request`\\n\\n- Fix concurrent access to payload in `RequestHandle.handle_request()`\\n\\n- Add access logging to `aiohttp.web`\\n\\n- Gunicorn worker for `aiohttp.web`\\n\\n- Removed deprecated `AsyncGunicornWorker`\\n\\n- Removed deprecated HttpClient\\n\\n\\n0.11.0 (11-29-2014)\\n-------------------\\n\\n- Support named routes in `aiohttp.web.UrlDispatcher` #179\\n\\n- Make websocket subprotocols conform to spec #181\\n\\n\\n0.10.2 (11-19-2014)\\n-------------------\\n\\n- Don't unquote `environ['PATH_INFO']` in wsgi.py #177\\n\\n\\n0.10.1 (11-17-2014)\\n-------------------\\n\\n- aiohttp.web.HTTPException and descendants now files response body\\n  with string like `404: NotFound`\\n\\n- Fix multidict `__iter__`, the method should iterate over keys, not\\n  (key, value) pairs.\\n\\n\\n0.10.0 (11-13-2014)\\n-------------------\\n\\n- Add aiohttp.web subpackage for highlevel HTTP server support.\\n\\n- Add *reason* optional parameter to aiohttp.protocol.Response ctor.\\n\\n- Fix aiohttp.client bug for sending file without content-type.\\n\\n- Change error text for connection closed between server responses\\n  from 'Can not read status line' to explicit 'Connection closed by\\n  server'\\n\\n- Drop closed connections from connector #173\\n\\n- Set server.transport to None on .closing() #172\\n\\n\\n0.9.3 (10-30-2014)\\n------------------\\n\\n- Fix compatibility with asyncio 3.4.1+ #170\\n\\n\\n0.9.2 (10-16-2014)\\n------------------\\n\\n- Improve redirect handling #157\\n\\n- Send raw files as is #153\\n\\n- Better websocket support #150\\n\\n\\n0.9.1 (08-30-2014)\\n------------------\\n\\n- Added MultiDict support for client request params and data #114.\\n\\n- Fixed parameter type for IncompleteRead exception #118.\\n\\n- Strictly require ASCII headers names and values #137\\n\\n- Keep port in ProxyConnector #128.\\n\\n- Python 3.4.1 compatibility #131.\\n\\n\\n0.9.0 (07-08-2014)\\n------------------\\n\\n- Better client basic authentication support #112.\\n\\n- Fixed incorrect line splitting in HttpRequestParser #97.\\n\\n- Support StreamReader and DataQueue as request data.\\n\\n- Client files handling refactoring #20.\\n\\n- Backward incompatible: Replace DataQueue with StreamReader for\\n  request payload #87.\\n\\n\\n0.8.4 (07-04-2014)\\n------------------\\n\\n- Change ProxyConnector authorization parameters.\\n\\n\\n0.8.3 (07-03-2014)\\n------------------\\n\\n- Publish TCPConnector properties: verify_ssl, family, resolve, resolved_hosts.\\n\\n- Don't parse message body for HEAD responses.\\n\\n- Refactor client response decoding.\\n\\n\\n0.8.2 (06-22-2014)\\n------------------\\n\\n- Make ProxyConnector.proxy immutable property.\\n\\n- Make UnixConnector.path immutable property.\\n\\n- Fix resource leak for aiohttp.request() with implicit connector.\\n\\n- Rename Connector's reuse_timeout to keepalive_timeout.\\n\\n\\n0.8.1 (06-18-2014)\\n------------------\\n\\n- Use case insensitive multidict for server request/response headers.\\n\\n- MultiDict.getall() accepts default value.\\n\\n- Catch server ConnectionError.\\n\\n- Accept MultiDict (and derived) instances in aiohttp.request header argument.\\n\\n- Proxy 'CONNECT' support.\\n\\n\\n0.8.0 (06-06-2014)\\n------------------\\n\\n- Add support for utf-8 values in HTTP headers\\n\\n- Allow to use custom response class instead of HttpResponse\\n\\n- Use MultiDict for client request headers\\n\\n- Use MultiDict for server request/response headers\\n\\n- Store response headers in ClientResponse.headers attribute\\n\\n- Get rid of timeout parameter in aiohttp.client API\\n\\n- Exceptions refactoring\\n\\n\\n0.7.3 (05-20-2014)\\n------------------\\n\\n- Simple HTTP proxy support.\\n\\n\\n0.7.2 (05-14-2014)\\n------------------\\n\\n- Get rid of `__del__` methods\\n\\n- Use ResourceWarning instead of logging warning record.\\n\\n\\n0.7.1 (04-28-2014)\\n------------------\\n\\n- Do not unquote client request urls.\\n\\n- Allow multiple waiters on transport drain.\\n\\n- Do not return client connection to pool in case of exceptions.\\n\\n- Rename SocketConnector to TCPConnector and UnixSocketConnector to\\n  UnixConnector.\\n\\n\\n0.7.0 (04-16-2014)\\n------------------\\n\\n- Connection flow control.\\n\\n- HTTP client session/connection pool refactoring.\\n\\n- Better handling for bad server requests.\\n\\n\\n0.6.5 (03-29-2014)\\n------------------\\n\\n- Added client session reuse timeout.\\n\\n- Better client request cancellation support.\\n\\n- Better handling responses without content length.\\n\\n- Added HttpClient verify_ssl parameter support.\\n\\n\\n0.6.4 (02-27-2014)\\n------------------\\n\\n- Log content-length missing warning only for put and post requests.\\n\\n\\n0.6.3 (02-27-2014)\\n------------------\\n\\n- Better support for server exit.\\n\\n- Read response body until EOF if content-length is not defined #14\\n\\n\\n0.6.2 (02-18-2014)\\n------------------\\n\\n- Fix trailing char in allowed_methods.\\n\\n- Start slow request timer for first request.\\n\\n\\n0.6.1 (02-17-2014)\\n------------------\\n\\n- Added utility method HttpResponse.read_and_close()\\n\\n- Added slow request timeout.\\n\\n- Enable socket SO_KEEPALIVE if available.\\n\\n\\n0.6.0 (02-12-2014)\\n------------------\\n\\n- Better handling for process exit.\\n\\n\\n0.5.0 (01-29-2014)\\n------------------\\n\\n- Allow to use custom HttpRequest client class.\\n\\n- Use gunicorn keepalive setting for asynchronous worker.\\n\\n- Log leaking responses.\\n\\n- python 3.4 compatibility\\n\\n\\n0.4.4 (11-15-2013)\\n------------------\\n\\n- Resolve only AF_INET family, because it is not clear how to pass\\n  extra info to asyncio.\\n\\n\\n0.4.3 (11-15-2013)\\n------------------\\n\\n- Allow to wait completion of request with `HttpResponse.wait_for_close()`\\n\\n\\n0.4.2 (11-14-2013)\\n------------------\\n\\n- Handle exception in client request stream.\\n\\n- Prevent host resolving for each client request.\\n\\n\\n0.4.1 (11-12-2013)\\n------------------\\n\\n- Added client support for `expect: 100-continue` header.\\n\\n\\n0.4 (11-06-2013)\\n----------------\\n\\n- Added custom wsgi application close procedure\\n\\n- Fixed concurrent host failure in HttpClient\\n\\n\\n0.3 (11-04-2013)\\n----------------\\n\\n- Added PortMapperWorker\\n\\n- Added HttpClient\\n\\n- Added TCP connection timeout to HTTP client\\n\\n- Better client connection errors handling\\n\\n- Gracefully handle process exit\\n\\n\\n0.2\\n---\\n\\n- Fix packaging\\n\",\n            \"new_file_content\": \"0.18.1 (20-10-2015)\\n-------------------\\n\\n- Relax rule for router names: they may contain dots and columns\\n  starting from now\\n\\n0.18.0 (19-10-2015)\\n-------------------\\n\\n- Use errors.HttpProcessingError.message as HTTP error reason and\\n  message #459\\n\\n- Optimize cythonized multidict a bit\\n\\n- Change repr's of multidicts and multidict views\\n\\n- default headers in ClientSession are now case-insensitive\\n\\n- Make '=' char and 'wss://' schema safe in urls #477\\n\\n- `ClientResponse.close()` forces connection closing by default from now #479\\n\\n  N.B. Backward incompatible change: was `.close(force=False) Using\\n  `force` parameter for the method is deprecated: use `.release()`\\n  instead.\\n\\n- Properly requote URL's path #480\\n\\n- add `skip_auto_headers` parameter for client API #486\\n\\n- Properly parse URL path in aiohttp.web.Request #489\\n\\n- Raise RuntimeError when chunked enabled and HTTP is 1.0 #488\\n\\n- Fix a bug with processing io.BytesIO as data parameter for client API #500\\n\\n- Skip auto-generation of Content-Type header #507\\n\\n- Use sendfile facility for static file handling #503\\n\\n- Default `response_factory` in `app.router.add_static` now is\\n  `StreamResponse`, not `None`. The functionality is not changed if\\n  default is not specified.\\n\\n- Drop `ClientResponse.message` attribute, it was always implementation detail.\\n\\n- Streams are optimized for speed and mostly memory in case of a big\\n  HTTP message sizes #496\\n\\n- Fix a bug for server-side cookies for dropping cookie and setting it\\n  again without Max-Age parameter.\\n\\n- Don't trim redirect URL in client API #499\\n\\n- Extend precision of access log \\\"D\\\" to milliseconds #527\\n\\n- Deprecate `StreamResponse.start()` method in favor of\\n  `StreamResponse.prepare()` coroutine #525\\n\\n  `.start()` is still supported but responses begun with `.start()`\\n  doesn't call signal for response preparing to be sent.\\n\\n- Add `StreamReader.__repr__`\\n\\n- Drop Python 3.3 support, from now minimal required version is Python\\n  3.4.1 #541\\n\\n- Add `async with` support for `ClientSession.request()` and family #536\\n\\n- Ignore message body on 204 and 304 responses #505\\n\\n- `TCPConnector` processed both IPv4 and IPv6 by default #559\\n\\n- Add `.routes()` view for urldispatcher #519\\n\\n- Route name should be a valid identifier name from now #567\\n\\n- Implement server signals #562\\n\\n- Drop an year-old deprecated *files* parameter from client API.\\n\\n- Added `async for` support for aiohttp stream #542\\n\\n0.17.4 (09-29-2015)\\n-------------------\\n\\n- Properly parse URL path in aiohttp.web.Request #489\\n\\n- Add missing coroutine decorator, the client api is await-compatible now\\n\\n0.17.3 (08-28-2015)\\n---------------------\\n\\n- Remove Content-Length header on compressed responses #450\\n\\n- Support Python 3.5\\n\\n- Improve performance of transport in-use list #472\\n\\n- Fix connection pooling #473\\n\\n0.17.2 (08-11-2015)\\n---------------------\\n\\n- Don't forget to pass `data` argument forward #462\\n\\n- Fix multipart read bytes count #463\\n\\n0.17.1 (08-10-2015)\\n---------------------\\n\\n- Fix multidict comparsion to arbitrary abc.Mapping\\n\\n0.17.0 (08-04-2015)\\n---------------------\\n\\n- Make StaticRoute support Last-Modified and If-Modified-Since headers #386\\n\\n- Add Request.if_modified_since and Stream.Response.last_modified properties\\n\\n- Fix deflate compression when writing a chunked response #395\\n\\n- Request`s content-length header is cleared now after redirect from\\n  POST method #391\\n\\n- Return a 400 if server received a non HTTP content #405\\n\\n- Fix keep-alive support for aiohttp clients #406\\n\\n- Allow gzip compression in high-level server response interface #403\\n\\n- Rename TCPConnector.resolve and family to dns_cache #415\\n\\n- Make UrlDispatcher ignore quoted characters during url matching #414\\n  Backward-compatibility warning: this may change the url matched by\\n  your queries if they send quoted character (like %2F for /) #414\\n\\n- Use optional cchardet accelerator if present #418\\n\\n- Borrow loop from Connector in ClientSession if loop is not set\\n\\n- Add context manager support to ClientSession for session closing.\\n\\n- Add toplevel get(), post(), put(), head(), delete(), options(),\\n  patch() coroutines.\\n\\n- Fix IPv6 support for client API #425\\n\\n- Pass SSL context through proxy connector #421\\n\\n- Make the rule: path for add_route should start with slash\\n\\n- Don't process request finishing by low-level server on closed event loop\\n\\n- Don't override data if multiple files are uploaded with same key #433\\n\\n- Ensure multipart.BodyPartReader.read_chunk read all the necessary data\\n  to avoid false assertions about malformed multipart payload\\n\\n- Dont sent body for 204, 205 and 304 http exceptions #442\\n\\n- Correctly skip Cython compilation in MSVC not found #453\\n\\n- Add response factory to StaticRoute #456\\n\\n- Don't append trailing CRLF for multipart.BodyPartReader #454\\n\\n\\n0.16.6 (07-15-2015)\\n-------------------\\n\\n- Skip compilation on Windows if vcvarsall.bat cannot be found #438\\n\\n0.16.5 (06-13-2015)\\n-------------------\\n\\n- Get rid of all comprehensions and yielding in _multidict #410\\n\\n\\n0.16.4 (06-13-2015)\\n-------------------\\n\\n- Don't clear current exception in multidict's `__repr__` (cythonized\\n  versions) #410\\n\\n\\n0.16.3 (05-30-2015)\\n-------------------\\n\\n- Fix StaticRoute vulnerability to directory traversal attacks #380\\n\\n\\n0.16.2 (05-27-2015)\\n-------------------\\n\\n- Update python version required for `__del__` usage: it's actually\\n  3.4.1 instead of 3.4.0\\n\\n- Add check for presence of loop.is_closed() method before call the\\n  former #378\\n\\n\\n0.16.1 (05-27-2015)\\n-------------------\\n\\n- Fix regression in static file handling #377\\n\\n0.16.0 (05-26-2015)\\n-------------------\\n\\n- Unset waiter future after cancellation #363\\n\\n- Update request url with query parameters #372\\n\\n- Support new `fingerprint` param of TCPConnector to enable verifying\\n  SSL certificates via MD5, SHA1, or SHA256 digest #366\\n\\n- Setup uploaded filename if field value is binary and transfer\\n  encoding is not specified #349\\n\\n- Implement `ClientSession.close()` method\\n\\n- Implement `connector.closed` readonly property\\n\\n- Implement `ClientSession.closed` readonly property\\n\\n- Implement `ClientSession.connector` readonly property\\n\\n- Implement `ClientSession.detach` method\\n\\n- Add `__del__` to client-side objects: sessions, connectors,\\n  connections, requests, responses.\\n\\n- Refactor connections cleanup by connector #357\\n\\n- Add `limit` parameter to connector constructor #358\\n\\n- Add `request.has_body` property #364\\n\\n- Add `response_class` parameter to `ws_connect()` #367\\n\\n- `ProxyConnector` doesn't support keep-alive requests by default\\n  starting from now #368\\n\\n- Add `connector.force_close` property\\n\\n- Add ws_connect to ClientSession #374\\n\\n- Support optional `chunk_size` parameter in `router.add_static()`\\n\\n\\n0.15.3 (04-22-2015)\\n-------------------\\n\\n- Fix graceful shutdown handling\\n\\n- Fix `Expect` header handling for not found and not allowed routes #340\\n\\n\\n0.15.2 (04-19-2015)\\n-------------------\\n\\n- Flow control subsystem refactoring\\n\\n- HTTP server performace optimizations\\n\\n- Allow to match any request method with `*`\\n\\n- Explicitly call drain on transport #316\\n\\n- Make chardet module dependency mandatory #318\\n\\n- Support keep-alive for HTTP 1.0 #325\\n\\n- Do not chunk single file during upload #327\\n\\n- Add ClientSession object for cookie storage and default headers #328\\n\\n- Add `keep_alive_on` argument for HTTP server handler.\\n\\n\\n0.15.1 (03-31-2015)\\n-------------------\\n\\n- Pass Autobahn Testsuit tests\\n\\n- Fixed websocket fragmentation\\n\\n- Fixed websocket close procedure\\n\\n- Fixed parser buffer limits\\n\\n- Added `timeout` parameter to WebSocketResponse ctor\\n\\n- Added `WebSocketResponse.close_code` attribute\\n\\n\\n0.15.0 (03-27-2015)\\n-------------------\\n\\n- Client WebSockets support\\n\\n- New Multipart system #273\\n\\n- Support for \\\"Except\\\" header #287 #267\\n\\n- Set default Content-Type for post requests #184\\n\\n- Fix issue with construction dynamic route with regexps and trailing slash #266\\n\\n- Add repr to web.Request\\n\\n- Add repr to web.Response\\n\\n- Add repr for NotFound and NotAllowed match infos\\n\\n- Add repr for web.Application\\n\\n- Add repr to UrlMappingMatchInfo #217\\n\\n- Gunicorn 19.2.x compatibility\\n\\n\\n0.14.4 (01-29-2015)\\n-------------------\\n\\n- Fix issue with error during constructing of url with regex parts #264\\n\\n\\n0.14.3 (01-28-2015)\\n-------------------\\n\\n- Use path='/' by default for cookies #261\\n\\n\\n0.14.2 (01-23-2015)\\n-------------------\\n\\n- Connections leak in BaseConnector #253\\n\\n- Do not swallow websocket reader exceptions #255\\n\\n- web.Request's read, text, json are memorized #250\\n\\n\\n0.14.1 (01-15-2015)\\n-------------------\\n\\n- HttpMessage._add_default_headers does not overwrite existing headers #216\\n\\n- Expose multidict classes at package level\\n\\n- add `aiohttp.web.WebSocketResponse`\\n\\n- According to RFC 6455 websocket subprotocol preference order is\\n  provided by client, not by server\\n\\n- websocket's ping and pong accept optional message parameter\\n\\n- multidict views do not accept `getall` parameter anymore, it\\n  returns the full body anyway.\\n\\n- multidicts have optional Cython optimization, cythonized version of\\n  multidicts is about 5 times faster than pure Python.\\n\\n- multidict.getall() returns `list`, not `tuple`.\\n\\n- Backward imcompatible change: now there are two mutable multidicts\\n  (`MultiDict`, `CIMultiDict`) and two immutable multidict proxies\\n  (`MultiDictProxy` and `CIMultiDictProxy`). Previous edition of\\n  multidicts was not a part of public API BTW.\\n\\n- Router refactoring to push Not Allowed and Not Found in middleware processing\\n\\n- Convert `ConnectionError` to `aiohttp.DisconnectedError` and don't\\n  eat `ConnectionError` exceptions from web handlers.\\n\\n- Remove hop headers from Response class, wsgi response still uses hop headers.\\n\\n- Allow to send raw chunked encoded response.\\n\\n- Allow to encode output bytes stream into chunked encoding.\\n\\n- Allow to compress output bytes stream with `deflate` encoding.\\n\\n- Server has 75 seconds keepalive timeout now, was non-keepalive by default.\\n\\n- Application doesn't accept `**kwargs` anymore (#243).\\n\\n- Request is inherited from dict now for making per-request storage to\\n  middlewares (#242).\\n\\n\\n0.13.1 (12-31-2014)\\n--------------------\\n\\n- Add `aiohttp.web.StreamResponse.started` property #213\\n\\n- Html escape traceback text in `ServerHttpProtocol.handle_error`\\n\\n- Mention handler and middlewares in `aiohttp.web.RequestHandler.handle_request`\\n  on error (#218)\\n\\n\\n0.13.0 (12-29-2014)\\n-------------------\\n\\n- `StreamResponse.charset` converts value to lower-case on assigning.\\n\\n- Chain exceptions when raise `ClientRequestError`.\\n\\n- Support custom regexps in route variables #204\\n\\n- Fixed graceful shutdown, disable keep-alive on connection closing.\\n\\n- Decode HTTP message with `utf-8` encoding, some servers send headers\\n  in utf-8 encoding #207\\n\\n- Support `aiohtt.web` middlewares #209\\n\\n- Add ssl_context to TCPConnector #206\\n\\n\\n0.12.0 (12-12-2014)\\n-------------------\\n\\n- Deep refactoring of `aiohttp.web` in backward-incompatible manner.\\n  Sorry, we have to do this.\\n\\n- Automatically force aiohttp.web handlers to coroutines in\\n  `UrlDispatcher.add_route()` #186\\n\\n- Rename `Request.POST()` function to `Request.post()`\\n\\n- Added POST attribute\\n\\n- Response processing refactoring: constructor does't accept Request\\n  instance anymore.\\n\\n- Pass application instance to finish callback\\n\\n- Exceptions refactoring\\n\\n- Do not unquote query string in `aiohttp.web.Request`\\n\\n- Fix concurrent access to payload in `RequestHandle.handle_request()`\\n\\n- Add access logging to `aiohttp.web`\\n\\n- Gunicorn worker for `aiohttp.web`\\n\\n- Removed deprecated `AsyncGunicornWorker`\\n\\n- Removed deprecated HttpClient\\n\\n\\n0.11.0 (11-29-2014)\\n-------------------\\n\\n- Support named routes in `aiohttp.web.UrlDispatcher` #179\\n\\n- Make websocket subprotocols conform to spec #181\\n\\n\\n0.10.2 (11-19-2014)\\n-------------------\\n\\n- Don't unquote `environ['PATH_INFO']` in wsgi.py #177\\n\\n\\n0.10.1 (11-17-2014)\\n-------------------\\n\\n- aiohttp.web.HTTPException and descendants now files response body\\n  with string like `404: NotFound`\\n\\n- Fix multidict `__iter__`, the method should iterate over keys, not\\n  (key, value) pairs.\\n\\n\\n0.10.0 (11-13-2014)\\n-------------------\\n\\n- Add aiohttp.web subpackage for highlevel HTTP server support.\\n\\n- Add *reason* optional parameter to aiohttp.protocol.Response ctor.\\n\\n- Fix aiohttp.client bug for sending file without content-type.\\n\\n- Change error text for connection closed between server responses\\n  from 'Can not read status line' to explicit 'Connection closed by\\n  server'\\n\\n- Drop closed connections from connector #173\\n\\n- Set server.transport to None on .closing() #172\\n\\n\\n0.9.3 (10-30-2014)\\n------------------\\n\\n- Fix compatibility with asyncio 3.4.1+ #170\\n\\n\\n0.9.2 (10-16-2014)\\n------------------\\n\\n- Improve redirect handling #157\\n\\n- Send raw files as is #153\\n\\n- Better websocket support #150\\n\\n\\n0.9.1 (08-30-2014)\\n------------------\\n\\n- Added MultiDict support for client request params and data #114.\\n\\n- Fixed parameter type for IncompleteRead exception #118.\\n\\n- Strictly require ASCII headers names and values #137\\n\\n- Keep port in ProxyConnector #128.\\n\\n- Python 3.4.1 compatibility #131.\\n\\n\\n0.9.0 (07-08-2014)\\n------------------\\n\\n- Better client basic authentication support #112.\\n\\n- Fixed incorrect line splitting in HttpRequestParser #97.\\n\\n- Support StreamReader and DataQueue as request data.\\n\\n- Client files handling refactoring #20.\\n\\n- Backward incompatible: Replace DataQueue with StreamReader for\\n  request payload #87.\\n\\n\\n0.8.4 (07-04-2014)\\n------------------\\n\\n- Change ProxyConnector authorization parameters.\\n\\n\\n0.8.3 (07-03-2014)\\n------------------\\n\\n- Publish TCPConnector properties: verify_ssl, family, resolve, resolved_hosts.\\n\\n- Don't parse message body for HEAD responses.\\n\\n- Refactor client response decoding.\\n\\n\\n0.8.2 (06-22-2014)\\n------------------\\n\\n- Make ProxyConnector.proxy immutable property.\\n\\n- Make UnixConnector.path immutable property.\\n\\n- Fix resource leak for aiohttp.request() with implicit connector.\\n\\n- Rename Connector's reuse_timeout to keepalive_timeout.\\n\\n\\n0.8.1 (06-18-2014)\\n------------------\\n\\n- Use case insensitive multidict for server request/response headers.\\n\\n- MultiDict.getall() accepts default value.\\n\\n- Catch server ConnectionError.\\n\\n- Accept MultiDict (and derived) instances in aiohttp.request header argument.\\n\\n- Proxy 'CONNECT' support.\\n\\n\\n0.8.0 (06-06-2014)\\n------------------\\n\\n- Add support for utf-8 values in HTTP headers\\n\\n- Allow to use custom response class instead of HttpResponse\\n\\n- Use MultiDict for client request headers\\n\\n- Use MultiDict for server request/response headers\\n\\n- Store response headers in ClientResponse.headers attribute\\n\\n- Get rid of timeout parameter in aiohttp.client API\\n\\n- Exceptions refactoring\\n\\n\\n0.7.3 (05-20-2014)\\n------------------\\n\\n- Simple HTTP proxy support.\\n\\n\\n0.7.2 (05-14-2014)\\n------------------\\n\\n- Get rid of `__del__` methods\\n\\n- Use ResourceWarning instead of logging warning record.\\n\\n\\n0.7.1 (04-28-2014)\\n------------------\\n\\n- Do not unquote client request urls.\\n\\n- Allow multiple waiters on transport drain.\\n\\n- Do not return client connection to pool in case of exceptions.\\n\\n- Rename SocketConnector to TCPConnector and UnixSocketConnector to\\n  UnixConnector.\\n\\n\\n0.7.0 (04-16-2014)\\n------------------\\n\\n- Connection flow control.\\n\\n- HTTP client session/connection pool refactoring.\\n\\n- Better handling for bad server requests.\\n\\n\\n0.6.5 (03-29-2014)\\n------------------\\n\\n- Added client session reuse timeout.\\n\\n- Better client request cancellation support.\\n\\n- Better handling responses without content length.\\n\\n- Added HttpClient verify_ssl parameter support.\\n\\n\\n0.6.4 (02-27-2014)\\n------------------\\n\\n- Log content-length missing warning only for put and post requests.\\n\\n\\n0.6.3 (02-27-2014)\\n------------------\\n\\n- Better support for server exit.\\n\\n- Read response body until EOF if content-length is not defined #14\\n\\n\\n0.6.2 (02-18-2014)\\n------------------\\n\\n- Fix trailing char in allowed_methods.\\n\\n- Start slow request timer for first request.\\n\\n\\n0.6.1 (02-17-2014)\\n------------------\\n\\n- Added utility method HttpResponse.read_and_close()\\n\\n- Added slow request timeout.\\n\\n- Enable socket SO_KEEPALIVE if available.\\n\\n\\n0.6.0 (02-12-2014)\\n------------------\\n\\n- Better handling for process exit.\\n\\n\\n0.5.0 (01-29-2014)\\n------------------\\n\\n- Allow to use custom HttpRequest client class.\\n\\n- Use gunicorn keepalive setting for asynchronous worker.\\n\\n- Log leaking responses.\\n\\n- python 3.4 compatibility\\n\\n\\n0.4.4 (11-15-2013)\\n------------------\\n\\n- Resolve only AF_INET family, because it is not clear how to pass\\n  extra info to asyncio.\\n\\n\\n0.4.3 (11-15-2013)\\n------------------\\n\\n- Allow to wait completion of request with `HttpResponse.wait_for_close()`\\n\\n\\n0.4.2 (11-14-2013)\\n------------------\\n\\n- Handle exception in client request stream.\\n\\n- Prevent host resolving for each client request.\\n\\n\\n0.4.1 (11-12-2013)\\n------------------\\n\\n- Added client support for `expect: 100-continue` header.\\n\\n\\n0.4 (11-06-2013)\\n----------------\\n\\n- Added custom wsgi application close procedure\\n\\n- Fixed concurrent host failure in HttpClient\\n\\n\\n0.3 (11-04-2013)\\n----------------\\n\\n- Added PortMapperWorker\\n\\n- Added HttpClient\\n\\n- Added TCP connection timeout to HTTP client\\n\\n- Better client connection errors handling\\n\\n- Gracefully handle process exit\\n\\n\\n0.2\\n---\\n\\n- Fix packaging\\n\",\n            \"header\": {\n                \"file\": {\n                    \"path\": \"HISTORY.rst\"\n                },\n                \"misc_line\": null\n            },\n            \"index_line\": {\n                \"old_commit_hash\": \"6514ae8a\",\n                \"new_commit_hash\": \"a3b10b04\",\n                \"mode\": \"100644\"\n            },\n            \"is_binary_file\": false,\n            \"binary_line\": null,\n            \"minus_file\": {\n                \"path\": \"a/HISTORY.rst\"\n            },\n            \"plus_file\": {\n                \"path\": \"b/HISTORY.rst\"\n            },\n            \"hunks\": [\n                {\n                    \"descriptor\": {\n                        \"old_range\": {\n                            \"start\": 1,\n                            \"length\": 3\n                        },\n                        \"new_range\": {\n                            \"start\": 1,\n                            \"length\": 9\n                        },\n                        \"section\": \"\"\n                    },\n                    \"line_group\": {\n                        \"all_lines\": [\n                            {\n                                \"content\": \"0.18.1 (20-10-2015)\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"-------------------\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"- Relax rule for router names: they may contain dots and columns\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"  starting from now\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"0.18.0 (19-10-2015)\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"-------------------\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"\",\n                                \"type\": \"context\"\n                            }\n                        ]\n                    },\n                    \"modified_entities\": [],\n                    \"added_entities\": [],\n                    \"deleted_entities\": []\n                }\n            ]\n        },\n        {\n            \"old_file_content\": \"import abc\\nimport asyncio\\n\\nimport keyword\\nimport collections\\nimport mimetypes\\nimport re\\nimport os\\nimport inspect\\n\\nfrom collections.abc import Sized, Iterable, Container\\nfrom urllib.parse import urlencode, unquote\\n\\nfrom . import hdrs\\nfrom .abc import AbstractRouter, AbstractMatchInfo\\nfrom .protocol import HttpVersion11\\nfrom .web_exceptions import HTTPMethodNotAllowed, HTTPNotFound, HTTPNotModified\\nfrom .web_reqrep import StreamResponse\\nfrom .multidict import upstr\\n\\n\\n__all__ = ('UrlDispatcher', 'UrlMappingMatchInfo',\\n           'Route', 'PlainRoute', 'DynamicRoute', 'StaticRoute')\\n\\n\\nclass UrlMappingMatchInfo(dict, AbstractMatchInfo):\\n\\n    def __init__(self, match_dict, route):\\n        super().__init__(match_dict)\\n        self._route = route\\n\\n    @property\\n    def handler(self):\\n        return self._route.handler\\n\\n    @property\\n    def route(self):\\n        return self._route\\n\\n    def __repr__(self):\\n        return \\\"<MatchInfo {}: {}>\\\".format(super().__repr__(), self._route)\\n\\n\\n@asyncio.coroutine\\ndef _defaultExpectHandler(request):\\n    \\\"\\\"\\\"Default handler for Except: 100-continue\\\"\\\"\\\"\\n    if request.version == HttpVersion11:\\n        request.transport.write(b\\\"HTTP/1.1 100 Continue\\\\r\\\\n\\\\r\\\\n\\\")\\n\\n\\nclass Route(metaclass=abc.ABCMeta):\\n\\n    def __init__(self, method, handler, name, *, expect_handler=None):\\n        if expect_handler is None:\\n            expect_handler = _defaultExpectHandler\\n        assert asyncio.iscoroutinefunction(expect_handler), \\\\\\n            'Coroutine is expected, got {!r}'.format(expect_handler)\\n\\n        self._method = method\\n        self._handler = handler\\n        self._name = name\\n        self._expect_handler = expect_handler\\n\\n    @property\\n    def method(self):\\n        return self._method\\n\\n    @property\\n    def handler(self):\\n        return self._handler\\n\\n    @property\\n    def name(self):\\n        return self._name\\n\\n    @abc.abstractmethod  # pragma: no branch\\n    def match(self, path):\\n        \\\"\\\"\\\"Return dict with info for given path or\\n        None if route cannot process path.\\\"\\\"\\\"\\n\\n    @abc.abstractmethod  # pragma: no branch\\n    def url(self, **kwargs):\\n        \\\"\\\"\\\"Construct url for route with additional params.\\\"\\\"\\\"\\n\\n    @asyncio.coroutine\\n    def handle_expect_header(self, request):\\n        return (yield from self._expect_handler(request))\\n\\n    @staticmethod\\n    def _append_query(url, query):\\n        if query is not None:\\n            return url + \\\"?\\\" + urlencode(query)\\n        else:\\n            return url\\n\\n\\nclass PlainRoute(Route):\\n\\n    def __init__(self, method, handler, name, path, *, expect_handler=None):\\n        super().__init__(method, handler, name, expect_handler=expect_handler)\\n        self._path = path\\n\\n    def match(self, path):\\n        # string comparison is about 10 times faster than regexp matching\\n        if self._path == path:\\n            return {}\\n        else:\\n            return None\\n\\n    def url(self, *, query=None):\\n        return self._append_query(self._path, query)\\n\\n    def __repr__(self):\\n        name = \\\"'\\\" + self.name + \\\"' \\\" if self.name is not None else \\\"\\\"\\n        return \\\"<PlainRoute {name}[{method}] {path} -> {handler!r}\\\".format(\\n            name=name, method=self.method, path=self._path,\\n            handler=self.handler)\\n\\n\\nclass DynamicRoute(Route):\\n\\n    def __init__(self, method, handler, name, pattern, formatter, *,\\n                 expect_handler=None):\\n        super().__init__(method, handler, name, expect_handler=expect_handler)\\n        self._pattern = pattern\\n        self._formatter = formatter\\n\\n    def match(self, path):\\n        match = self._pattern.match(path)\\n        if match is None:\\n            return None\\n        else:\\n            return match.groupdict()\\n\\n    def url(self, *, parts, query=None):\\n        url = self._formatter.format_map(parts)\\n        return self._append_query(url, query)\\n\\n    def __repr__(self):\\n        name = \\\"'\\\" + self.name + \\\"' \\\" if self.name is not None else \\\"\\\"\\n        return (\\\"<DynamicRoute {name}[{method}] {formatter} -> {handler!r}\\\"\\n                .format(name=name, method=self.method,\\n                        formatter=self._formatter, handler=self.handler))\\n\\n\\nclass StaticRoute(Route):\\n\\n    def __init__(self, name, prefix, directory, *,\\n                 expect_handler=None, chunk_size=256*1024,\\n                 response_factory=StreamResponse):\\n        assert prefix.startswith('/'), prefix\\n        assert prefix.endswith('/'), prefix\\n        super().__init__(\\n            'GET', self.handle, name, expect_handler=expect_handler)\\n        self._prefix = prefix\\n        self._prefix_len = len(self._prefix)\\n        self._directory = os.path.abspath(directory) + os.sep\\n        self._chunk_size = chunk_size\\n        self._response_factory = response_factory\\n\\n        if not os.path.isdir(self._directory):\\n            raise ValueError(\\n                \\\"No directory exists at '{}'\\\".format(self._directory))\\n\\n    def match(self, path):\\n        if not path.startswith(self._prefix):\\n            return None\\n        return {'filename': path[self._prefix_len:]}\\n\\n    def url(self, *, filename, query=None):\\n        while filename.startswith('/'):\\n            filename = filename[1:]\\n        url = self._prefix + filename\\n        return self._append_query(url, query)\\n\\n    def _sendfile_cb(self, fut, out_fd, in_fd, offset, count, loop,\\n                     registered):\\n        if registered:\\n            loop.remove_writer(out_fd)\\n        try:\\n            n = os.sendfile(out_fd, in_fd, offset, count)\\n            if n == 0:  # EOF reached\\n                n = count\\n        except (BlockingIOError, InterruptedError):\\n            n = 0\\n        except Exception as exc:\\n            fut.set_exception(exc)\\n            return\\n\\n        if n < count:\\n            loop.add_writer(out_fd, self._sendfile_cb, fut, out_fd, in_fd,\\n                            offset + n, count - n, loop, True)\\n        else:\\n            fut.set_result(None)\\n\\n    @asyncio.coroutine\\n    def _sendfile_system(self, req, resp, fobj, count):\\n        \\\"\\\"\\\"\\n        Write `count` bytes of `fobj` to `resp` starting from `offset` using\\n        the ``sendfile`` system call.\\n\\n        `req` should be a :obj:`aiohttp.web.Request` instance.\\n\\n        `resp` should be a :obj:`aiohttp.web.StreamResponse` instance.\\n\\n        `fobj` should be an open file object.\\n\\n        `offset` should be an integer >= 0.\\n\\n        `count` should be an integer > 0.\\n        \\\"\\\"\\\"\\n        transport = req.transport\\n\\n        if transport.get_extra_info(\\\"sslcontext\\\"):\\n            yield from self._sendfile_fallback(req, resp, fobj, count)\\n            return\\n\\n        yield from resp.drain()\\n\\n        loop = req.app.loop\\n        out_fd = transport.get_extra_info(\\\"socket\\\").fileno()\\n        in_fd = fobj.fileno()\\n        fut = asyncio.Future(loop=loop)\\n\\n        self._sendfile_cb(fut, out_fd, in_fd, 0, count, loop, False)\\n\\n        yield from fut\\n\\n    @asyncio.coroutine\\n    def _sendfile_fallback(self, req, resp, fobj, count):\\n        \\\"\\\"\\\"\\n        Mimic the :meth:`_sendfile_system` method, but without using the\\n        ``sendfile`` system call. This should be used on systems that don't\\n        support the ``sendfile`` system call.\\n\\n        To avoid blocking the event loop & to keep memory usage low, `fobj` is\\n        transferred in chunks controlled by the `chunk_size` argument to\\n        :class:`StaticRoute`.\\n        \\\"\\\"\\\"\\n        chunk_size = self._chunk_size\\n\\n        chunk = fobj.read(chunk_size)\\n        while chunk and count > chunk_size:\\n            resp.write(chunk)\\n            yield from resp.drain()\\n            count = count - chunk_size\\n            chunk = fobj.read(chunk_size)\\n\\n        if chunk:\\n            resp.write(chunk[:count])\\n            yield from resp.drain()\\n\\n    if hasattr(os, \\\"sendfile\\\"):  # pragma: no cover\\n        _sendfile = _sendfile_system\\n    else:  # pragma: no cover\\n        _sendfile = _sendfile_fallback\\n\\n    @asyncio.coroutine\\n    def handle(self, request):\\n        filename = request.match_info['filename']\\n        filepath = os.path.abspath(os.path.join(self._directory, filename))\\n        if not filepath.startswith(self._directory):\\n            raise HTTPNotFound()\\n        if not os.path.exists(filepath) or not os.path.isfile(filepath):\\n            raise HTTPNotFound()\\n\\n        st = os.stat(filepath)\\n\\n        modsince = request.if_modified_since\\n        if modsince is not None and st.st_mtime <= modsince.timestamp():\\n            raise HTTPNotModified()\\n\\n        ct, encoding = mimetypes.guess_type(filepath)\\n        if not ct:\\n            ct = 'application/octet-stream'\\n\\n        resp = self._response_factory()\\n        resp.content_type = ct\\n        if encoding:\\n            resp.headers[hdrs.CONTENT_ENCODING] = encoding\\n        resp.last_modified = st.st_mtime\\n\\n        file_size = st.st_size\\n\\n        resp.content_length = file_size\\n        yield from resp.prepare(request)\\n\\n        with open(filepath, 'rb') as f:\\n            yield from self._sendfile(request, resp, f, file_size)\\n\\n        return resp\\n\\n    def __repr__(self):\\n        name = \\\"'\\\" + self.name + \\\"' \\\" if self.name is not None else \\\"\\\"\\n        return \\\"<StaticRoute {name}[{method}] {path} -> {directory!r}\\\".format(\\n            name=name, method=self.method, path=self._prefix,\\n            directory=self._directory)\\n\\n\\nclass SystemRoute(Route):\\n\\n    def __init__(self, status, reason):\\n        super().__init__(hdrs.METH_ANY, None, None)\\n        self._status = status\\n        self._reason = reason\\n\\n    def url(self, **kwargs):\\n        raise RuntimeError(\\\".url() is not allowed for SystemRoute\\\")\\n\\n    def match(self, path):\\n        return None\\n\\n    @property\\n    def status(self):\\n        return self._status\\n\\n    @property\\n    def reason(self):\\n        return self._reason\\n\\n    def __repr__(self):\\n        return \\\"<SystemRoute {status}: {reason}>\\\".format(status=self._status,\\n                                                         reason=self._reason)\\n\\n\\nclass _NotFoundMatchInfo(UrlMappingMatchInfo):\\n\\n    route = SystemRoute(404, 'Not Found')\\n\\n    def __init__(self):\\n        super().__init__({}, None)\\n\\n    @property\\n    def handler(self):\\n        return self._not_found\\n\\n    @asyncio.coroutine\\n    def _not_found(self, request):\\n        raise HTTPNotFound()\\n\\n    def __repr__(self):\\n        return \\\"<MatchInfo: not found>\\\"\\n\\n\\nclass _MethodNotAllowedMatchInfo(UrlMappingMatchInfo):\\n\\n    route = SystemRoute(405, 'Method Not Allowed')\\n\\n    def __init__(self, method, allowed_methods):\\n        super().__init__({}, None)\\n        self._method = method\\n        self._allowed_methods = allowed_methods\\n\\n    @property\\n    def handler(self):\\n        return self._not_allowed\\n\\n    @asyncio.coroutine\\n    def _not_allowed(self, request):\\n        raise HTTPMethodNotAllowed(self._method, self._allowed_methods)\\n\\n    def __repr__(self):\\n        return (\\\"<MatchInfo: method {} is not allowed (allowed methods: {}>\\\"\\n                .format(self._method,\\n                        ', '.join(sorted(self._allowed_methods))))\\n\\n\\nclass RoutesView(Sized, Iterable, Container):\\n\\n    __slots__ = '_urls'\\n\\n    def __init__(self, urls):\\n        self._urls = urls\\n\\n    def __len__(self):\\n        return len(self._urls)\\n\\n    def __iter__(self):\\n        yield from self._urls\\n\\n    def __contains__(self, route):\\n        return route in self._urls\\n\\n\\nclass UrlDispatcher(AbstractRouter, collections.abc.Mapping):\\n\\n    DYN = re.compile(r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*)\\\\}$')\\n    DYN_WITH_RE = re.compile(\\n        r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*):(?P<re>.+)\\\\}$')\\n    GOOD = r'[^{}/]+'\\n    ROUTE_RE = re.compile(r'(\\\\{[_a-zA-Z][^{}]*(?:\\\\{[^{}]*\\\\}[^{}]*)*\\\\})')\\n\\n    METHODS = {hdrs.METH_ANY, hdrs.METH_POST,\\n               hdrs.METH_GET, hdrs.METH_PUT, hdrs.METH_DELETE,\\n               hdrs.METH_PATCH, hdrs.METH_HEAD, hdrs.METH_OPTIONS}\\n\\n    def __init__(self):\\n        super().__init__()\\n        self._urls = []\\n        self._routes = {}\\n\\n    @asyncio.coroutine\\n    def resolve(self, request):\\n        path = request.raw_path\\n        method = request.method\\n        allowed_methods = set()\\n\\n        for route in self._urls:\\n            match_dict = route.match(path)\\n            if match_dict is None:\\n                continue\\n\\n            route_method = route.method\\n            if route_method == method or route_method == hdrs.METH_ANY:\\n                # Unquote separate matching parts\\n                match_dict = {key: unquote(value) for key, value in\\n                              match_dict.items()}\\n                return UrlMappingMatchInfo(match_dict, route)\\n\\n            allowed_methods.add(route_method)\\n        else:\\n            if allowed_methods:\\n                return _MethodNotAllowedMatchInfo(method, allowed_methods)\\n            else:\\n                return _NotFoundMatchInfo()\\n\\n    def __iter__(self):\\n        return iter(self._routes)\\n\\n    def __len__(self):\\n        return len(self._routes)\\n\\n    def __contains__(self, name):\\n        return name in self._routes\\n\\n    def __getitem__(self, name):\\n        return self._routes[name]\\n\\n    def routes(self):\\n        return RoutesView(self._urls)\\n\\n    def register_route(self, route):\\n        assert isinstance(route, Route), 'Instance of Route class is required.'\\n\\n        name = route.name\\n\\n        if name is not None:\\n            if not name.isidentifier() or keyword.iskeyword(name):\\n                raise ValueError('Incorrect route name value, '\\n                                 'Route name should be python identifier')\\n            elif name in self._routes:\\n                raise ValueError('Duplicate {!r}, '\\n                                 'already handled by {!r}'\\n                                 .format(name, self._routes[name]))\\n            else:\\n                self._routes[name] = route\\n        self._urls.append(route)\\n\\n    def add_route(self, method, path, handler,\\n                  *, name=None, expect_handler=None):\\n\\n        if not path.startswith('/'):\\n            raise ValueError(\\\"path should be started with /\\\")\\n\\n        assert callable(handler), handler\\n        if (not asyncio.iscoroutinefunction(handler) and\\n                not inspect.isgeneratorfunction(handler)):\\n            handler = asyncio.coroutine(handler)\\n\\n        method = upstr(method)\\n        if method not in self.METHODS:\\n            raise ValueError(\\\"{} is not allowed HTTP method\\\".format(method))\\n\\n        if not ('{' in path or '}' in path or self.ROUTE_RE.search(path)):\\n            route = PlainRoute(\\n                method, handler, name, path, expect_handler=expect_handler)\\n            self.register_route(route)\\n            return route\\n\\n        pattern = ''\\n        formatter = ''\\n        for part in self.ROUTE_RE.split(path):\\n            match = self.DYN.match(part)\\n            if match:\\n                pattern += '(?P<{}>{})'.format(match.group('var'), self.GOOD)\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            match = self.DYN_WITH_RE.match(part)\\n            if match:\\n                pattern += '(?P<{var}>{re})'.format(**match.groupdict())\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            if '{' in part or '}' in part:\\n                raise ValueError(\\\"Invalid path '{}'['{}']\\\".format(path, part))\\n\\n            formatter += part\\n            pattern += re.escape(part)\\n\\n        try:\\n            compiled = re.compile('^' + pattern + '$')\\n        except re.error as exc:\\n            raise ValueError(\\n                \\\"Bad pattern '{}': {}\\\".format(pattern, exc)) from None\\n        route = DynamicRoute(\\n            method, handler, name, compiled,\\n            formatter, expect_handler=expect_handler)\\n        self.register_route(route)\\n        return route\\n\\n    def add_static(self, prefix, path, *, name=None, expect_handler=None,\\n                   chunk_size=256*1024, response_factory=StreamResponse):\\n        \\\"\\\"\\\"\\n        Adds static files view\\n        :param prefix - url prefix\\n        :param path - folder with files\\n        \\\"\\\"\\\"\\n        assert prefix.startswith('/')\\n        if not prefix.endswith('/'):\\n            prefix += '/'\\n        route = StaticRoute(name, prefix, path,\\n                            expect_handler=expect_handler,\\n                            chunk_size=chunk_size,\\n                            response_factory=response_factory)\\n        self.register_route(route)\\n        return route\\n\",\n            \"new_file_content\": \"import abc\\nimport asyncio\\n\\nimport keyword\\nimport collections\\nimport mimetypes\\nimport re\\nimport os\\nimport inspect\\n\\nfrom collections.abc import Sized, Iterable, Container\\nfrom urllib.parse import urlencode, unquote\\n\\nfrom . import hdrs\\nfrom .abc import AbstractRouter, AbstractMatchInfo\\nfrom .protocol import HttpVersion11\\nfrom .web_exceptions import HTTPMethodNotAllowed, HTTPNotFound, HTTPNotModified\\nfrom .web_reqrep import StreamResponse\\nfrom .multidict import upstr\\n\\n\\n__all__ = ('UrlDispatcher', 'UrlMappingMatchInfo',\\n           'Route', 'PlainRoute', 'DynamicRoute', 'StaticRoute')\\n\\n\\nclass UrlMappingMatchInfo(dict, AbstractMatchInfo):\\n\\n    def __init__(self, match_dict, route):\\n        super().__init__(match_dict)\\n        self._route = route\\n\\n    @property\\n    def handler(self):\\n        return self._route.handler\\n\\n    @property\\n    def route(self):\\n        return self._route\\n\\n    def __repr__(self):\\n        return \\\"<MatchInfo {}: {}>\\\".format(super().__repr__(), self._route)\\n\\n\\n@asyncio.coroutine\\ndef _defaultExpectHandler(request):\\n    \\\"\\\"\\\"Default handler for Except: 100-continue\\\"\\\"\\\"\\n    if request.version == HttpVersion11:\\n        request.transport.write(b\\\"HTTP/1.1 100 Continue\\\\r\\\\n\\\\r\\\\n\\\")\\n\\n\\nclass Route(metaclass=abc.ABCMeta):\\n\\n    def __init__(self, method, handler, name, *, expect_handler=None):\\n        if expect_handler is None:\\n            expect_handler = _defaultExpectHandler\\n        assert asyncio.iscoroutinefunction(expect_handler), \\\\\\n            'Coroutine is expected, got {!r}'.format(expect_handler)\\n\\n        self._method = method\\n        self._handler = handler\\n        self._name = name\\n        self._expect_handler = expect_handler\\n\\n    @property\\n    def method(self):\\n        return self._method\\n\\n    @property\\n    def handler(self):\\n        return self._handler\\n\\n    @property\\n    def name(self):\\n        return self._name\\n\\n    @abc.abstractmethod  # pragma: no branch\\n    def match(self, path):\\n        \\\"\\\"\\\"Return dict with info for given path or\\n        None if route cannot process path.\\\"\\\"\\\"\\n\\n    @abc.abstractmethod  # pragma: no branch\\n    def url(self, **kwargs):\\n        \\\"\\\"\\\"Construct url for route with additional params.\\\"\\\"\\\"\\n\\n    @asyncio.coroutine\\n    def handle_expect_header(self, request):\\n        return (yield from self._expect_handler(request))\\n\\n    @staticmethod\\n    def _append_query(url, query):\\n        if query is not None:\\n            return url + \\\"?\\\" + urlencode(query)\\n        else:\\n            return url\\n\\n\\nclass PlainRoute(Route):\\n\\n    def __init__(self, method, handler, name, path, *, expect_handler=None):\\n        super().__init__(method, handler, name, expect_handler=expect_handler)\\n        self._path = path\\n\\n    def match(self, path):\\n        # string comparison is about 10 times faster than regexp matching\\n        if self._path == path:\\n            return {}\\n        else:\\n            return None\\n\\n    def url(self, *, query=None):\\n        return self._append_query(self._path, query)\\n\\n    def __repr__(self):\\n        name = \\\"'\\\" + self.name + \\\"' \\\" if self.name is not None else \\\"\\\"\\n        return \\\"<PlainRoute {name}[{method}] {path} -> {handler!r}\\\".format(\\n            name=name, method=self.method, path=self._path,\\n            handler=self.handler)\\n\\n\\nclass DynamicRoute(Route):\\n\\n    def __init__(self, method, handler, name, pattern, formatter, *,\\n                 expect_handler=None):\\n        super().__init__(method, handler, name, expect_handler=expect_handler)\\n        self._pattern = pattern\\n        self._formatter = formatter\\n\\n    def match(self, path):\\n        match = self._pattern.match(path)\\n        if match is None:\\n            return None\\n        else:\\n            return match.groupdict()\\n\\n    def url(self, *, parts, query=None):\\n        url = self._formatter.format_map(parts)\\n        return self._append_query(url, query)\\n\\n    def __repr__(self):\\n        name = \\\"'\\\" + self.name + \\\"' \\\" if self.name is not None else \\\"\\\"\\n        return (\\\"<DynamicRoute {name}[{method}] {formatter} -> {handler!r}\\\"\\n                .format(name=name, method=self.method,\\n                        formatter=self._formatter, handler=self.handler))\\n\\n\\nclass StaticRoute(Route):\\n\\n    def __init__(self, name, prefix, directory, *,\\n                 expect_handler=None, chunk_size=256*1024,\\n                 response_factory=StreamResponse):\\n        assert prefix.startswith('/'), prefix\\n        assert prefix.endswith('/'), prefix\\n        super().__init__(\\n            'GET', self.handle, name, expect_handler=expect_handler)\\n        self._prefix = prefix\\n        self._prefix_len = len(self._prefix)\\n        self._directory = os.path.abspath(directory) + os.sep\\n        self._chunk_size = chunk_size\\n        self._response_factory = response_factory\\n\\n        if not os.path.isdir(self._directory):\\n            raise ValueError(\\n                \\\"No directory exists at '{}'\\\".format(self._directory))\\n\\n    def match(self, path):\\n        if not path.startswith(self._prefix):\\n            return None\\n        return {'filename': path[self._prefix_len:]}\\n\\n    def url(self, *, filename, query=None):\\n        while filename.startswith('/'):\\n            filename = filename[1:]\\n        url = self._prefix + filename\\n        return self._append_query(url, query)\\n\\n    def _sendfile_cb(self, fut, out_fd, in_fd, offset, count, loop,\\n                     registered):\\n        if registered:\\n            loop.remove_writer(out_fd)\\n        try:\\n            n = os.sendfile(out_fd, in_fd, offset, count)\\n            if n == 0:  # EOF reached\\n                n = count\\n        except (BlockingIOError, InterruptedError):\\n            n = 0\\n        except Exception as exc:\\n            fut.set_exception(exc)\\n            return\\n\\n        if n < count:\\n            loop.add_writer(out_fd, self._sendfile_cb, fut, out_fd, in_fd,\\n                            offset + n, count - n, loop, True)\\n        else:\\n            fut.set_result(None)\\n\\n    @asyncio.coroutine\\n    def _sendfile_system(self, req, resp, fobj, count):\\n        \\\"\\\"\\\"\\n        Write `count` bytes of `fobj` to `resp` starting from `offset` using\\n        the ``sendfile`` system call.\\n\\n        `req` should be a :obj:`aiohttp.web.Request` instance.\\n\\n        `resp` should be a :obj:`aiohttp.web.StreamResponse` instance.\\n\\n        `fobj` should be an open file object.\\n\\n        `offset` should be an integer >= 0.\\n\\n        `count` should be an integer > 0.\\n        \\\"\\\"\\\"\\n        transport = req.transport\\n\\n        if transport.get_extra_info(\\\"sslcontext\\\"):\\n            yield from self._sendfile_fallback(req, resp, fobj, count)\\n            return\\n\\n        yield from resp.drain()\\n\\n        loop = req.app.loop\\n        out_fd = transport.get_extra_info(\\\"socket\\\").fileno()\\n        in_fd = fobj.fileno()\\n        fut = asyncio.Future(loop=loop)\\n\\n        self._sendfile_cb(fut, out_fd, in_fd, 0, count, loop, False)\\n\\n        yield from fut\\n\\n    @asyncio.coroutine\\n    def _sendfile_fallback(self, req, resp, fobj, count):\\n        \\\"\\\"\\\"\\n        Mimic the :meth:`_sendfile_system` method, but without using the\\n        ``sendfile`` system call. This should be used on systems that don't\\n        support the ``sendfile`` system call.\\n\\n        To avoid blocking the event loop & to keep memory usage low, `fobj` is\\n        transferred in chunks controlled by the `chunk_size` argument to\\n        :class:`StaticRoute`.\\n        \\\"\\\"\\\"\\n        chunk_size = self._chunk_size\\n\\n        chunk = fobj.read(chunk_size)\\n        while chunk and count > chunk_size:\\n            resp.write(chunk)\\n            yield from resp.drain()\\n            count = count - chunk_size\\n            chunk = fobj.read(chunk_size)\\n\\n        if chunk:\\n            resp.write(chunk[:count])\\n            yield from resp.drain()\\n\\n    if hasattr(os, \\\"sendfile\\\"):  # pragma: no cover\\n        _sendfile = _sendfile_system\\n    else:  # pragma: no cover\\n        _sendfile = _sendfile_fallback\\n\\n    @asyncio.coroutine\\n    def handle(self, request):\\n        filename = request.match_info['filename']\\n        filepath = os.path.abspath(os.path.join(self._directory, filename))\\n        if not filepath.startswith(self._directory):\\n            raise HTTPNotFound()\\n        if not os.path.exists(filepath) or not os.path.isfile(filepath):\\n            raise HTTPNotFound()\\n\\n        st = os.stat(filepath)\\n\\n        modsince = request.if_modified_since\\n        if modsince is not None and st.st_mtime <= modsince.timestamp():\\n            raise HTTPNotModified()\\n\\n        ct, encoding = mimetypes.guess_type(filepath)\\n        if not ct:\\n            ct = 'application/octet-stream'\\n\\n        resp = self._response_factory()\\n        resp.content_type = ct\\n        if encoding:\\n            resp.headers[hdrs.CONTENT_ENCODING] = encoding\\n        resp.last_modified = st.st_mtime\\n\\n        file_size = st.st_size\\n\\n        resp.content_length = file_size\\n        yield from resp.prepare(request)\\n\\n        with open(filepath, 'rb') as f:\\n            yield from self._sendfile(request, resp, f, file_size)\\n\\n        return resp\\n\\n    def __repr__(self):\\n        name = \\\"'\\\" + self.name + \\\"' \\\" if self.name is not None else \\\"\\\"\\n        return \\\"<StaticRoute {name}[{method}] {path} -> {directory!r}\\\".format(\\n            name=name, method=self.method, path=self._prefix,\\n            directory=self._directory)\\n\\n\\nclass SystemRoute(Route):\\n\\n    def __init__(self, status, reason):\\n        super().__init__(hdrs.METH_ANY, None, None)\\n        self._status = status\\n        self._reason = reason\\n\\n    def url(self, **kwargs):\\n        raise RuntimeError(\\\".url() is not allowed for SystemRoute\\\")\\n\\n    def match(self, path):\\n        return None\\n\\n    @property\\n    def status(self):\\n        return self._status\\n\\n    @property\\n    def reason(self):\\n        return self._reason\\n\\n    def __repr__(self):\\n        return \\\"<SystemRoute {status}: {reason}>\\\".format(status=self._status,\\n                                                         reason=self._reason)\\n\\n\\nclass _NotFoundMatchInfo(UrlMappingMatchInfo):\\n\\n    route = SystemRoute(404, 'Not Found')\\n\\n    def __init__(self):\\n        super().__init__({}, None)\\n\\n    @property\\n    def handler(self):\\n        return self._not_found\\n\\n    @asyncio.coroutine\\n    def _not_found(self, request):\\n        raise HTTPNotFound()\\n\\n    def __repr__(self):\\n        return \\\"<MatchInfo: not found>\\\"\\n\\n\\nclass _MethodNotAllowedMatchInfo(UrlMappingMatchInfo):\\n\\n    route = SystemRoute(405, 'Method Not Allowed')\\n\\n    def __init__(self, method, allowed_methods):\\n        super().__init__({}, None)\\n        self._method = method\\n        self._allowed_methods = allowed_methods\\n\\n    @property\\n    def handler(self):\\n        return self._not_allowed\\n\\n    @asyncio.coroutine\\n    def _not_allowed(self, request):\\n        raise HTTPMethodNotAllowed(self._method, self._allowed_methods)\\n\\n    def __repr__(self):\\n        return (\\\"<MatchInfo: method {} is not allowed (allowed methods: {}>\\\"\\n                .format(self._method,\\n                        ', '.join(sorted(self._allowed_methods))))\\n\\n\\nclass RoutesView(Sized, Iterable, Container):\\n\\n    __slots__ = '_urls'\\n\\n    def __init__(self, urls):\\n        self._urls = urls\\n\\n    def __len__(self):\\n        return len(self._urls)\\n\\n    def __iter__(self):\\n        yield from self._urls\\n\\n    def __contains__(self, route):\\n        return route in self._urls\\n\\n\\nclass UrlDispatcher(AbstractRouter, collections.abc.Mapping):\\n\\n    DYN = re.compile(r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*)\\\\}$')\\n    DYN_WITH_RE = re.compile(\\n        r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*):(?P<re>.+)\\\\}$')\\n    GOOD = r'[^{}/]+'\\n    ROUTE_RE = re.compile(r'(\\\\{[_a-zA-Z][^{}]*(?:\\\\{[^{}]*\\\\}[^{}]*)*\\\\})')\\n    NAME_SPLIT_RE = re.compile('[.:]')\\n\\n    METHODS = {hdrs.METH_ANY, hdrs.METH_POST,\\n               hdrs.METH_GET, hdrs.METH_PUT, hdrs.METH_DELETE,\\n               hdrs.METH_PATCH, hdrs.METH_HEAD, hdrs.METH_OPTIONS}\\n\\n    def __init__(self):\\n        super().__init__()\\n        self._urls = []\\n        self._routes = {}\\n\\n    @asyncio.coroutine\\n    def resolve(self, request):\\n        path = request.raw_path\\n        method = request.method\\n        allowed_methods = set()\\n\\n        for route in self._urls:\\n            match_dict = route.match(path)\\n            if match_dict is None:\\n                continue\\n\\n            route_method = route.method\\n            if route_method == method or route_method == hdrs.METH_ANY:\\n                # Unquote separate matching parts\\n                match_dict = {key: unquote(value) for key, value in\\n                              match_dict.items()}\\n                return UrlMappingMatchInfo(match_dict, route)\\n\\n            allowed_methods.add(route_method)\\n        else:\\n            if allowed_methods:\\n                return _MethodNotAllowedMatchInfo(method, allowed_methods)\\n            else:\\n                return _NotFoundMatchInfo()\\n\\n    def __iter__(self):\\n        return iter(self._routes)\\n\\n    def __len__(self):\\n        return len(self._routes)\\n\\n    def __contains__(self, name):\\n        return name in self._routes\\n\\n    def __getitem__(self, name):\\n        return self._routes[name]\\n\\n    def routes(self):\\n        return RoutesView(self._urls)\\n\\n    def register_route(self, route):\\n        assert isinstance(route, Route), 'Instance of Route class is required.'\\n\\n        name = route.name\\n\\n        if name is not None:\\n            parts = self.NAME_SPLIT_RE.split(name)\\n            for part in parts:\\n                if not part.isidentifier() or keyword.iskeyword(part):\\n                    raise ValueError('Incorrect route name value, '\\n                                     'Route name should be a sequence of '\\n                                     'python identifiers separated '\\n                                     'by dot or column')\\n            if name in self._routes:\\n                raise ValueError('Duplicate {!r}, '\\n                                 'already handled by {!r}'\\n                                 .format(name, self._routes[name]))\\n            self._routes[name] = route\\n        self._urls.append(route)\\n\\n    def add_route(self, method, path, handler,\\n                  *, name=None, expect_handler=None):\\n\\n        if not path.startswith('/'):\\n            raise ValueError(\\\"path should be started with /\\\")\\n\\n        assert callable(handler), handler\\n        if (not asyncio.iscoroutinefunction(handler) and\\n                not inspect.isgeneratorfunction(handler)):\\n            handler = asyncio.coroutine(handler)\\n\\n        method = upstr(method)\\n        if method not in self.METHODS:\\n            raise ValueError(\\\"{} is not allowed HTTP method\\\".format(method))\\n\\n        if not ('{' in path or '}' in path or self.ROUTE_RE.search(path)):\\n            route = PlainRoute(\\n                method, handler, name, path, expect_handler=expect_handler)\\n            self.register_route(route)\\n            return route\\n\\n        pattern = ''\\n        formatter = ''\\n        for part in self.ROUTE_RE.split(path):\\n            match = self.DYN.match(part)\\n            if match:\\n                pattern += '(?P<{}>{})'.format(match.group('var'), self.GOOD)\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            match = self.DYN_WITH_RE.match(part)\\n            if match:\\n                pattern += '(?P<{var}>{re})'.format(**match.groupdict())\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            if '{' in part or '}' in part:\\n                raise ValueError(\\\"Invalid path '{}'['{}']\\\".format(path, part))\\n\\n            formatter += part\\n            pattern += re.escape(part)\\n\\n        try:\\n            compiled = re.compile('^' + pattern + '$')\\n        except re.error as exc:\\n            raise ValueError(\\n                \\\"Bad pattern '{}': {}\\\".format(pattern, exc)) from None\\n        route = DynamicRoute(\\n            method, handler, name, compiled,\\n            formatter, expect_handler=expect_handler)\\n        self.register_route(route)\\n        return route\\n\\n    def add_static(self, prefix, path, *, name=None, expect_handler=None,\\n                   chunk_size=256*1024, response_factory=StreamResponse):\\n        \\\"\\\"\\\"\\n        Adds static files view\\n        :param prefix - url prefix\\n        :param path - folder with files\\n        \\\"\\\"\\\"\\n        assert prefix.startswith('/')\\n        if not prefix.endswith('/'):\\n            prefix += '/'\\n        route = StaticRoute(name, prefix, path,\\n                            expect_handler=expect_handler,\\n                            chunk_size=chunk_size,\\n                            response_factory=response_factory)\\n        self.register_route(route)\\n        return route\\n\",\n            \"header\": {\n                \"file\": {\n                    \"path\": \"aiohttp/web_urldispatcher.py\"\n                },\n                \"misc_line\": null\n            },\n            \"index_line\": {\n                \"old_commit_hash\": \"58c8c2e6\",\n                \"new_commit_hash\": \"2400fddc\",\n                \"mode\": \"100644\"\n            },\n            \"is_binary_file\": false,\n            \"binary_line\": null,\n            \"minus_file\": {\n                \"path\": \"a/aiohttp/web_urldispatcher.py\"\n            },\n            \"plus_file\": {\n                \"path\": \"b/aiohttp/web_urldispatcher.py\"\n            },\n            \"hunks\": [\n                {\n                    \"descriptor\": {\n                        \"old_range\": {\n                            \"start\": 389,\n                            \"length\": 6\n                        },\n                        \"new_range\": {\n                            \"start\": 389,\n                            \"length\": 7\n                        },\n                        \"section\": \"class UrlDispatcher(AbstractRouter, collections.abc.Mapping):\"\n                    },\n                    \"line_group\": {\n                        \"all_lines\": [\n                            {\n                                \"content\": \"        r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*):(?P<re>.+)\\\\}$')\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"    GOOD = r'[^{}/]+'\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"    ROUTE_RE = re.compile(r'(\\\\{[_a-zA-Z][^{}]*(?:\\\\{[^{}]*\\\\}[^{}]*)*\\\\})')\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"    NAME_SPLIT_RE = re.compile('[.:]')\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"    METHODS = {hdrs.METH_ANY, hdrs.METH_POST,\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"               hdrs.METH_GET, hdrs.METH_PUT, hdrs.METH_DELETE,\",\n                                \"type\": \"context\"\n                            }\n                        ]\n                    },\n                    \"modified_entities\": [\n                        {\n                            \"file_name\": \"aiohttp/web_urldispatcher.py\",\n                            \"type\": \"class\",\n                            \"name\": \"UrlDispatcher\",\n                            \"content\": \"class UrlDispatcher(AbstractRouter, collections.abc.Mapping):\\n\\n    DYN = re.compile(r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*)\\\\}$')\\n    DYN_WITH_RE = re.compile(\\n        r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*):(?P<re>.+)\\\\}$')\\n    GOOD = r'[^{}/]+'\\n    ROUTE_RE = re.compile(r'(\\\\{[_a-zA-Z][^{}]*(?:\\\\{[^{}]*\\\\}[^{}]*)*\\\\})')\\n    NAME_SPLIT_RE = re.compile('[.:]')\\n\\n    METHODS = {hdrs.METH_ANY, hdrs.METH_POST,\\n               hdrs.METH_GET, hdrs.METH_PUT, hdrs.METH_DELETE,\\n               hdrs.METH_PATCH, hdrs.METH_HEAD, hdrs.METH_OPTIONS}\\n\\n    def __init__(self):\\n        super().__init__()\\n        self._urls = []\\n        self._routes = {}\\n\\n    @asyncio.coroutine\\n    def resolve(self, request):\\n        path = request.raw_path\\n        method = request.method\\n        allowed_methods = set()\\n\\n        for route in self._urls:\\n            match_dict = route.match(path)\\n            if match_dict is None:\\n                continue\\n\\n            route_method = route.method\\n            if route_method == method or route_method == hdrs.METH_ANY:\\n                # Unquote separate matching parts\\n                match_dict = {key: unquote(value) for key, value in\\n                              match_dict.items()}\\n                return UrlMappingMatchInfo(match_dict, route)\\n\\n            allowed_methods.add(route_method)\\n        else:\\n            if allowed_methods:\\n                return _MethodNotAllowedMatchInfo(method, allowed_methods)\\n            else:\\n                return _NotFoundMatchInfo()\\n\\n    def __iter__(self):\\n        return iter(self._routes)\\n\\n    def __len__(self):\\n        return len(self._routes)\\n\\n    def __contains__(self, name):\\n        return name in self._routes\\n\\n    def __getitem__(self, name):\\n        return self._routes[name]\\n\\n    def routes(self):\\n        return RoutesView(self._urls)\\n\\n    def register_route(self, route):\\n        assert isinstance(route, Route), 'Instance of Route class is required.'\\n\\n        name = route.name\\n\\n        if name is not None:\\n            parts = self.NAME_SPLIT_RE.split(name)\\n            for part in parts:\\n                if not part.isidentifier() or keyword.iskeyword(part):\\n                    raise ValueError('Incorrect route name value, '\\n                                     'Route name should be a sequence of '\\n                                     'python identifiers separated '\\n                                     'by dot or column')\\n            if name in self._routes:\\n                raise ValueError('Duplicate {!r}, '\\n                                 'already handled by {!r}'\\n                                 .format(name, self._routes[name]))\\n            self._routes[name] = route\\n        self._urls.append(route)\\n\\n    def add_route(self, method, path, handler,\\n                  *, name=None, expect_handler=None):\\n\\n        if not path.startswith('/'):\\n            raise ValueError(\\\"path should be started with /\\\")\\n\\n        assert callable(handler), handler\\n        if (not asyncio.iscoroutinefunction(handler) and\\n                not inspect.isgeneratorfunction(handler)):\\n            handler = asyncio.coroutine(handler)\\n\\n        method = upstr(method)\\n        if method not in self.METHODS:\\n            raise ValueError(\\\"{} is not allowed HTTP method\\\".format(method))\\n\\n        if not ('{' in path or '}' in path or self.ROUTE_RE.search(path)):\\n            route = PlainRoute(\\n                method, handler, name, path, expect_handler=expect_handler)\\n            self.register_route(route)\\n            return route\\n\\n        pattern = ''\\n        formatter = ''\\n        for part in self.ROUTE_RE.split(path):\\n            match = self.DYN.match(part)\\n            if match:\\n                pattern += '(?P<{}>{})'.format(match.group('var'), self.GOOD)\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            match = self.DYN_WITH_RE.match(part)\\n            if match:\\n                pattern += '(?P<{var}>{re})'.format(**match.groupdict())\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            if '{' in part or '}' in part:\\n                raise ValueError(\\\"Invalid path '{}'['{}']\\\".format(path, part))\\n\\n            formatter += part\\n            pattern += re.escape(part)\\n\\n        try:\\n            compiled = re.compile('^' + pattern + '$')\\n        except re.error as exc:\\n            raise ValueError(\\n                \\\"Bad pattern '{}': {}\\\".format(pattern, exc)) from None\\n        route = DynamicRoute(\\n            method, handler, name, compiled,\\n            formatter, expect_handler=expect_handler)\\n        self.register_route(route)\\n        return route\\n\\n    def add_static(self, prefix, path, *, name=None, expect_handler=None,\\n                   chunk_size=256*1024, response_factory=StreamResponse):\\n        \\\"\\\"\\\"\\n        Adds static files view\\n        :param prefix - url prefix\\n        :param path - folder with files\\n        \\\"\\\"\\\"\\n        assert prefix.startswith('/')\\n        if not prefix.endswith('/'):\\n            prefix += '/'\\n        route = StaticRoute(name, prefix, path,\\n                            expect_handler=expect_handler,\\n                            chunk_size=chunk_size,\\n                            response_factory=response_factory)\\n        self.register_route(route)\\n        return route\",\n                            \"ast_type_str\": \"ClassDef\",\n                            \"start_lineno\": 385,\n                            \"end_lineno\": 531,\n                            \"parent\": null\n                        }\n                    ],\n                    \"added_entities\": [],\n                    \"deleted_entities\": []\n                },\n                {\n                    \"descriptor\": {\n                        \"old_range\": {\n                            \"start\": 445,\n                            \"length\": 15\n                        },\n                        \"new_range\": {\n                            \"start\": 446,\n                            \"length\": 18\n                        },\n                        \"section\": \"class UrlDispatcher(AbstractRouter, collections.abc.Mapping):\"\n                    },\n                    \"line_group\": {\n                        \"all_lines\": [\n                            {\n                                \"content\": \"        name = route.name\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"        if name is not None:\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"            if not name.isidentifier() or keyword.iskeyword(name):\",\n                                \"type\": \"deleted\"\n                            },\n                            {\n                                \"content\": \"                raise ValueError('Incorrect route name value, '\",\n                                \"type\": \"deleted\"\n                            },\n                            {\n                                \"content\": \"                                 'Route name should be python identifier')\",\n                                \"type\": \"deleted\"\n                            },\n                            {\n                                \"content\": \"            elif name in self._routes:\",\n                                \"type\": \"deleted\"\n                            },\n                            {\n                                \"content\": \"            parts = self.NAME_SPLIT_RE.split(name)\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"            for part in parts:\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"                if not part.isidentifier() or keyword.iskeyword(part):\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"                    raise ValueError('Incorrect route name value, '\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"                                     'Route name should be a sequence of '\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"                                     'python identifiers separated '\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"                                     'by dot or column')\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"            if name in self._routes:\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"                raise ValueError('Duplicate {!r}, '\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"                                 'already handled by {!r}'\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"                                 .format(name, self._routes[name]))\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"            else:\",\n                                \"type\": \"deleted\"\n                            },\n                            {\n                                \"content\": \"                self._routes[name] = route\",\n                                \"type\": \"deleted\"\n                            },\n                            {\n                                \"content\": \"            self._routes[name] = route\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"        self._urls.append(route)\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"    def add_route(self, method, path, handler,\",\n                                \"type\": \"context\"\n                            }\n                        ]\n                    },\n                    \"modified_entities\": [\n                        {\n                            \"file_name\": \"aiohttp/web_urldispatcher.py\",\n                            \"type\": \"class\",\n                            \"name\": \"UrlDispatcher\",\n                            \"content\": \"class UrlDispatcher(AbstractRouter, collections.abc.Mapping):\\n\\n    DYN = re.compile(r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*)\\\\}$')\\n    DYN_WITH_RE = re.compile(\\n        r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*):(?P<re>.+)\\\\}$')\\n    GOOD = r'[^{}/]+'\\n    ROUTE_RE = re.compile(r'(\\\\{[_a-zA-Z][^{}]*(?:\\\\{[^{}]*\\\\}[^{}]*)*\\\\})')\\n\\n    METHODS = {hdrs.METH_ANY, hdrs.METH_POST,\\n               hdrs.METH_GET, hdrs.METH_PUT, hdrs.METH_DELETE,\\n               hdrs.METH_PATCH, hdrs.METH_HEAD, hdrs.METH_OPTIONS}\\n\\n    def __init__(self):\\n        super().__init__()\\n        self._urls = []\\n        self._routes = {}\\n\\n    @asyncio.coroutine\\n    def resolve(self, request):\\n        path = request.raw_path\\n        method = request.method\\n        allowed_methods = set()\\n\\n        for route in self._urls:\\n            match_dict = route.match(path)\\n            if match_dict is None:\\n                continue\\n\\n            route_method = route.method\\n            if route_method == method or route_method == hdrs.METH_ANY:\\n                # Unquote separate matching parts\\n                match_dict = {key: unquote(value) for key, value in\\n                              match_dict.items()}\\n                return UrlMappingMatchInfo(match_dict, route)\\n\\n            allowed_methods.add(route_method)\\n        else:\\n            if allowed_methods:\\n                return _MethodNotAllowedMatchInfo(method, allowed_methods)\\n            else:\\n                return _NotFoundMatchInfo()\\n\\n    def __iter__(self):\\n        return iter(self._routes)\\n\\n    def __len__(self):\\n        return len(self._routes)\\n\\n    def __contains__(self, name):\\n        return name in self._routes\\n\\n    def __getitem__(self, name):\\n        return self._routes[name]\\n\\n    def routes(self):\\n        return RoutesView(self._urls)\\n\\n    def register_route(self, route):\\n        assert isinstance(route, Route), 'Instance of Route class is required.'\\n\\n        name = route.name\\n\\n        if name is not None:\\n            if not name.isidentifier() or keyword.iskeyword(name):\\n                raise ValueError('Incorrect route name value, '\\n                                 'Route name should be python identifier')\\n            elif name in self._routes:\\n                raise ValueError('Duplicate {!r}, '\\n                                 'already handled by {!r}'\\n                                 .format(name, self._routes[name]))\\n            else:\\n                self._routes[name] = route\\n        self._urls.append(route)\\n\\n    def add_route(self, method, path, handler,\\n                  *, name=None, expect_handler=None):\\n\\n        if not path.startswith('/'):\\n            raise ValueError(\\\"path should be started with /\\\")\\n\\n        assert callable(handler), handler\\n        if (not asyncio.iscoroutinefunction(handler) and\\n                not inspect.isgeneratorfunction(handler)):\\n            handler = asyncio.coroutine(handler)\\n\\n        method = upstr(method)\\n        if method not in self.METHODS:\\n            raise ValueError(\\\"{} is not allowed HTTP method\\\".format(method))\\n\\n        if not ('{' in path or '}' in path or self.ROUTE_RE.search(path)):\\n            route = PlainRoute(\\n                method, handler, name, path, expect_handler=expect_handler)\\n            self.register_route(route)\\n            return route\\n\\n        pattern = ''\\n        formatter = ''\\n        for part in self.ROUTE_RE.split(path):\\n            match = self.DYN.match(part)\\n            if match:\\n                pattern += '(?P<{}>{})'.format(match.group('var'), self.GOOD)\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            match = self.DYN_WITH_RE.match(part)\\n            if match:\\n                pattern += '(?P<{var}>{re})'.format(**match.groupdict())\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            if '{' in part or '}' in part:\\n                raise ValueError(\\\"Invalid path '{}'['{}']\\\".format(path, part))\\n\\n            formatter += part\\n            pattern += re.escape(part)\\n\\n        try:\\n            compiled = re.compile('^' + pattern + '$')\\n        except re.error as exc:\\n            raise ValueError(\\n                \\\"Bad pattern '{}': {}\\\".format(pattern, exc)) from None\\n        route = DynamicRoute(\\n            method, handler, name, compiled,\\n            formatter, expect_handler=expect_handler)\\n        self.register_route(route)\\n        return route\\n\\n    def add_static(self, prefix, path, *, name=None, expect_handler=None,\\n                   chunk_size=256*1024, response_factory=StreamResponse):\\n        \\\"\\\"\\\"\\n        Adds static files view\\n        :param prefix - url prefix\\n        :param path - folder with files\\n        \\\"\\\"\\\"\\n        assert prefix.startswith('/')\\n        if not prefix.endswith('/'):\\n            prefix += '/'\\n        route = StaticRoute(name, prefix, path,\\n                            expect_handler=expect_handler,\\n                            chunk_size=chunk_size,\\n                            response_factory=response_factory)\\n        self.register_route(route)\\n        return route\",\n                            \"ast_type_str\": \"ClassDef\",\n                            \"start_lineno\": 385,\n                            \"end_lineno\": 527,\n                            \"parent\": null\n                        },\n                        {\n                            \"file_name\": \"aiohttp/web_urldispatcher.py\",\n                            \"type\": \"method\",\n                            \"name\": \"UrlDispatcher.register_route\",\n                            \"content\": \"class UrlDispatcher(AbstractRouter, collections.abc.Mapping):\\n\\n    DYN = re.compile(r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*)\\\\}$')\\n    DYN_WITH_RE = re.compile(\\n        r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*):(?P<re>.+)\\\\}$')\\n    GOOD = r'[^{}/]+'\\n    ROUTE_RE = re.compile(r'(\\\\{[_a-zA-Z][^{}]*(?:\\\\{[^{}]*\\\\}[^{}]*)*\\\\})')\\n\\n    METHODS = {hdrs.METH_ANY, hdrs.METH_POST,\\n               hdrs.METH_GET, hdrs.METH_PUT, hdrs.METH_DELETE,\\n               hdrs.METH_PATCH, hdrs.METH_HEAD, hdrs.METH_OPTIONS}\\n\\n    def __init__(self):\\n        super().__init__()\\n        self._urls = []\\n        self._routes = {}\\n\\n    @asyncio.coroutine\\n    def resolve(self, request):\\n        path = request.raw_path\\n        method = request.method\\n        allowed_methods = set()\\n\\n        for route in self._urls:\\n            match_dict = route.match(path)\\n            if match_dict is None:\\n                continue\\n\\n            route_method = route.method\\n            if route_method == method or route_method == hdrs.METH_ANY:\\n                # Unquote separate matching parts\\n                match_dict = {key: unquote(value) for key, value in\\n                              match_dict.items()}\\n                return UrlMappingMatchInfo(match_dict, route)\\n\\n            allowed_methods.add(route_method)\\n        else:\\n            if allowed_methods:\\n                return _MethodNotAllowedMatchInfo(method, allowed_methods)\\n            else:\\n                return _NotFoundMatchInfo()\\n\\n    def __iter__(self):\\n        return iter(self._routes)\\n\\n    def __len__(self):\\n        return len(self._routes)\\n\\n    def __contains__(self, name):\\n        return name in self._routes\\n\\n    def __getitem__(self, name):\\n        return self._routes[name]\\n\\n    def routes(self):\\n        return RoutesView(self._urls)\\n\\n    def register_route(self, route):\\n        assert isinstance(route, Route), 'Instance of Route class is required.'\\n\\n        name = route.name\\n\\n        if name is not None:\\n            if not name.isidentifier() or keyword.iskeyword(name):\\n                raise ValueError('Incorrect route name value, '\\n                                 'Route name should be python identifier')\\n            elif name in self._routes:\\n                raise ValueError('Duplicate {!r}, '\\n                                 'already handled by {!r}'\\n                                 .format(name, self._routes[name]))\\n            else:\\n                self._routes[name] = route\\n        self._urls.append(route)\\n\\n    def add_route(self, method, path, handler,\\n                  *, name=None, expect_handler=None):\\n\\n        if not path.startswith('/'):\\n            raise ValueError(\\\"path should be started with /\\\")\\n\\n        assert callable(handler), handler\\n        if (not asyncio.iscoroutinefunction(handler) and\\n                not inspect.isgeneratorfunction(handler)):\\n            handler = asyncio.coroutine(handler)\\n\\n        method = upstr(method)\\n        if method not in self.METHODS:\\n            raise ValueError(\\\"{} is not allowed HTTP method\\\".format(method))\\n\\n        if not ('{' in path or '}' in path or self.ROUTE_RE.search(path)):\\n            route = PlainRoute(\\n                method, handler, name, path, expect_handler=expect_handler)\\n            self.register_route(route)\\n            return route\\n\\n        pattern = ''\\n        formatter = ''\\n        for part in self.ROUTE_RE.split(path):\\n            match = self.DYN.match(part)\\n            if match:\\n                pattern += '(?P<{}>{})'.format(match.group('var'), self.GOOD)\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            match = self.DYN_WITH_RE.match(part)\\n            if match:\\n                pattern += '(?P<{var}>{re})'.format(**match.groupdict())\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            if '{' in part or '}' in part:\\n                raise ValueError(\\\"Invalid path '{}'['{}']\\\".format(path, part))\\n\\n            formatter += part\\n            pattern += re.escape(part)\\n\\n        try:\\n            compiled = re.compile('^' + pattern + '$')\\n        except re.error as exc:\\n            raise ValueError(\\n                \\\"Bad pattern '{}': {}\\\".format(pattern, exc)) from None\\n        route = DynamicRoute(\\n            method, handler, name, compiled,\\n            formatter, expect_handler=expect_handler)\\n        self.register_route(route)\\n        return route\\n\\n    def add_static(self, prefix, path, *, name=None, expect_handler=None,\\n                   chunk_size=256*1024, response_factory=StreamResponse):\\n        \\\"\\\"\\\"\\n        Adds static files view\\n        :param prefix - url prefix\\n        :param path - folder with files\\n        \\\"\\\"\\\"\\n        assert prefix.startswith('/')\\n        if not prefix.endswith('/'):\\n            prefix += '/'\\n        route = StaticRoute(name, prefix, path,\\n                            expect_handler=expect_handler,\\n                            chunk_size=chunk_size,\\n                            response_factory=response_factory)\\n        self.register_route(route)\\n        return route\",\n                            \"ast_type_str\": \"ClassDef\",\n                            \"start_lineno\": 442,\n                            \"end_lineno\": 457,\n                            \"parent\": {\n                                \"file_name\": \"aiohttp/web_urldispatcher.py\",\n                                \"type\": \"class\",\n                                \"name\": \"UrlDispatcher\",\n                                \"content\": \"class UrlDispatcher(AbstractRouter, collections.abc.Mapping):\\n\\n    DYN = re.compile(r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*)\\\\}$')\\n    DYN_WITH_RE = re.compile(\\n        r'^\\\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*):(?P<re>.+)\\\\}$')\\n    GOOD = r'[^{}/]+'\\n    ROUTE_RE = re.compile(r'(\\\\{[_a-zA-Z][^{}]*(?:\\\\{[^{}]*\\\\}[^{}]*)*\\\\})')\\n\\n    METHODS = {hdrs.METH_ANY, hdrs.METH_POST,\\n               hdrs.METH_GET, hdrs.METH_PUT, hdrs.METH_DELETE,\\n               hdrs.METH_PATCH, hdrs.METH_HEAD, hdrs.METH_OPTIONS}\\n\\n    def __init__(self):\\n        super().__init__()\\n        self._urls = []\\n        self._routes = {}\\n\\n    @asyncio.coroutine\\n    def resolve(self, request):\\n        path = request.raw_path\\n        method = request.method\\n        allowed_methods = set()\\n\\n        for route in self._urls:\\n            match_dict = route.match(path)\\n            if match_dict is None:\\n                continue\\n\\n            route_method = route.method\\n            if route_method == method or route_method == hdrs.METH_ANY:\\n                # Unquote separate matching parts\\n                match_dict = {key: unquote(value) for key, value in\\n                              match_dict.items()}\\n                return UrlMappingMatchInfo(match_dict, route)\\n\\n            allowed_methods.add(route_method)\\n        else:\\n            if allowed_methods:\\n                return _MethodNotAllowedMatchInfo(method, allowed_methods)\\n            else:\\n                return _NotFoundMatchInfo()\\n\\n    def __iter__(self):\\n        return iter(self._routes)\\n\\n    def __len__(self):\\n        return len(self._routes)\\n\\n    def __contains__(self, name):\\n        return name in self._routes\\n\\n    def __getitem__(self, name):\\n        return self._routes[name]\\n\\n    def routes(self):\\n        return RoutesView(self._urls)\\n\\n    def register_route(self, route):\\n        assert isinstance(route, Route), 'Instance of Route class is required.'\\n\\n        name = route.name\\n\\n        if name is not None:\\n            if not name.isidentifier() or keyword.iskeyword(name):\\n                raise ValueError('Incorrect route name value, '\\n                                 'Route name should be python identifier')\\n            elif name in self._routes:\\n                raise ValueError('Duplicate {!r}, '\\n                                 'already handled by {!r}'\\n                                 .format(name, self._routes[name]))\\n            else:\\n                self._routes[name] = route\\n        self._urls.append(route)\\n\\n    def add_route(self, method, path, handler,\\n                  *, name=None, expect_handler=None):\\n\\n        if not path.startswith('/'):\\n            raise ValueError(\\\"path should be started with /\\\")\\n\\n        assert callable(handler), handler\\n        if (not asyncio.iscoroutinefunction(handler) and\\n                not inspect.isgeneratorfunction(handler)):\\n            handler = asyncio.coroutine(handler)\\n\\n        method = upstr(method)\\n        if method not in self.METHODS:\\n            raise ValueError(\\\"{} is not allowed HTTP method\\\".format(method))\\n\\n        if not ('{' in path or '}' in path or self.ROUTE_RE.search(path)):\\n            route = PlainRoute(\\n                method, handler, name, path, expect_handler=expect_handler)\\n            self.register_route(route)\\n            return route\\n\\n        pattern = ''\\n        formatter = ''\\n        for part in self.ROUTE_RE.split(path):\\n            match = self.DYN.match(part)\\n            if match:\\n                pattern += '(?P<{}>{})'.format(match.group('var'), self.GOOD)\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            match = self.DYN_WITH_RE.match(part)\\n            if match:\\n                pattern += '(?P<{var}>{re})'.format(**match.groupdict())\\n                formatter += '{' + match.group('var') + '}'\\n                continue\\n\\n            if '{' in part or '}' in part:\\n                raise ValueError(\\\"Invalid path '{}'['{}']\\\".format(path, part))\\n\\n            formatter += part\\n            pattern += re.escape(part)\\n\\n        try:\\n            compiled = re.compile('^' + pattern + '$')\\n        except re.error as exc:\\n            raise ValueError(\\n                \\\"Bad pattern '{}': {}\\\".format(pattern, exc)) from None\\n        route = DynamicRoute(\\n            method, handler, name, compiled,\\n            formatter, expect_handler=expect_handler)\\n        self.register_route(route)\\n        return route\\n\\n    def add_static(self, prefix, path, *, name=None, expect_handler=None,\\n                   chunk_size=256*1024, response_factory=StreamResponse):\\n        \\\"\\\"\\\"\\n        Adds static files view\\n        :param prefix - url prefix\\n        :param path - folder with files\\n        \\\"\\\"\\\"\\n        assert prefix.startswith('/')\\n        if not prefix.endswith('/'):\\n            prefix += '/'\\n        route = StaticRoute(name, prefix, path,\\n                            expect_handler=expect_handler,\\n                            chunk_size=chunk_size,\\n                            response_factory=response_factory)\\n        self.register_route(route)\\n        return route\",\n                                \"ast_type_str\": \"ClassDef\",\n                                \"start_lineno\": 385,\n                                \"end_lineno\": 527,\n                                \"parent\": null\n                            }\n                        }\n                    ],\n                    \"added_entities\": [],\n                    \"deleted_entities\": []\n                }\n            ]\n        },\n        {\n            \"old_file_content\": \"import asyncio\\nimport os\\nimport unittest\\nfrom collections.abc import Sized, Container, Iterable\\nfrom unittest import mock\\nfrom urllib.parse import unquote\\nimport aiohttp.web\\nfrom aiohttp import hdrs\\nfrom aiohttp.web import (UrlDispatcher, Request, Response,\\n                         HTTPMethodNotAllowed, HTTPNotFound)\\nfrom aiohttp.multidict import CIMultiDict\\nfrom aiohttp.protocol import HttpVersion, RawRequestMessage\\nfrom aiohttp.web_urldispatcher import (_defaultExpectHandler,\\n                                       DynamicRoute,\\n                                       PlainRoute,\\n                                       SystemRoute)\\n\\n\\nclass TestUrlDispatcher(unittest.TestCase):\\n\\n    def setUp(self):\\n        self.loop = asyncio.new_event_loop()\\n        asyncio.set_event_loop(None)\\n        self.router = UrlDispatcher()\\n\\n    def tearDown(self):\\n        self.loop.close()\\n\\n    def make_request(self, method, path):\\n        self.app = mock.Mock()\\n        message = RawRequestMessage(method, path, HttpVersion(1, 1),\\n                                    CIMultiDict(), False, False)\\n        self.payload = mock.Mock()\\n        self.transport = mock.Mock()\\n        self.reader = mock.Mock()\\n        self.writer = mock.Mock()\\n        req = Request(self.app, message, self.payload,\\n                      self.transport, self.reader, self.writer)\\n        return req\\n\\n    def make_handler(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            return Response(request)  # pragma: no cover\\n\\n        return handler\\n\\n    def test_system_route(self):\\n        route = SystemRoute(201, 'test')\\n        self.assertIsNone(route.match('any'))\\n        with self.assertRaises(RuntimeError):\\n            route.url()\\n        self.assertEqual(\\\"<SystemRoute 201: test>\\\", repr(route))\\n        self.assertEqual(201, route.status)\\n        self.assertEqual('test', route.reason)\\n\\n    def test_register_route(self):\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(route, info.route)\\n        self.assertIs(handler, info.handler)\\n        self.assertEqual(info.route.name, 'test')\\n\\n    def test_register_route_checks(self):\\n        self.assertRaises(\\n            AssertionError, self.router.register_route, object())\\n\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, '1bad name', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, 'return', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n    def test_add_route_root(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/', handler)\\n        req = self.make_request('GET', '/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_route_simple(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler)\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_matchdict(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/{to}', handler)\\n        req = self.make_request('GET', '/handler/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 'tail'}, info)\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_name(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler,\\n                              name='name')\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual('name', info.route.name)\\n\\n    def test_add_with_tailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path/', handler)\\n        req = self.make_request('GET', '/handler/to/path/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_add_invalid_path(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('GET', '/{/', handler)\\n\\n    def test_add_url_invalid1(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id', handler)\\n\\n    def test_add_url_invalid2(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}}', handler)\\n\\n    def test_add_url_invalid3(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}', handler)\\n\\n    def test_add_url_invalid4(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id\\\"}', handler)\\n\\n    def test_add_url_escaping(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/+$', handler)\\n\\n        req = self.make_request('GET', '/+$')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_any_method(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route(hdrs.METH_ANY, '/', handler)\\n\\n        req = self.make_request('GET', '/')\\n        info1 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info1)\\n        self.assertIs(route, info1.route)\\n\\n        req = self.make_request('POST', '/')\\n        info2 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info2)\\n\\n        self.assertIs(info1.route, info2.route)\\n\\n    def test_match_second_result_in_table(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/h1', handler1)\\n        self.router.add_route('POST', '/h2', handler2)\\n        req = self.make_request('POST', '/h2')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler2, info.handler)\\n\\n    def test_raise_method_not_allowed(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/', handler1)\\n        self.router.add_route('POST', '/', handler2)\\n        req = self.make_request('PUT', '/')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPMethodNotAllowed) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual('PUT', exc.method)\\n        self.assertEqual(405, exc.status)\\n        self.assertEqual({'POST', 'GET'}, exc.allowed_methods)\\n\\n    def test_raise_method_not_found(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/a', handler)\\n        req = self.make_request('GET', '/b')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPNotFound) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual(404, exc.status)\\n\\n    def test_double_add_url_with_the_same_name(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/get', handler1, name='name')\\n\\n        regexp = (\\\"Duplicate 'name', already handled by\\\")\\n        with self.assertRaisesRegex(ValueError, regexp):\\n            self.router.add_route('GET', '/get_other', handler2, name='name')\\n\\n    def test_route_plain(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get', handler, name='name')\\n        route2 = self.router['name']\\n        url = route2.url()\\n        self.assertEqual('/get', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_unknown_route_name(self):\\n        with self.assertRaises(KeyError):\\n            self.router['unknown']\\n\\n    def test_route_dynamic(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{name}', handler,\\n                                      name='name')\\n\\n        route2 = self.router['name']\\n        url = route2.url(parts={'name': 'John'})\\n        self.assertEqual('/get/John', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_with_qs(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get', handler, name='name')\\n\\n        url = self.router['name'].url(query=[('a', 'b'), ('c', 1)])\\n        self.assertEqual('/get?a=b&c=1', url)\\n\\n    def test_add_static(self):\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__),\\n                                       name='static')\\n        route2 = self.router['static']\\n        url = route2.url(filename='/dir/a.txt')\\n        self.assertEqual('/st/dir/a.txt', url)\\n        self.assertIs(route, route2)\\n\\n    def test_plain_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_static_not_match(self):\\n        self.router.add_static('/pre', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_with_trailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}/', handler, name='name')\\n        route = self.router['name']\\n        self.assertEqual({'name': 'John'}, route.match('/get/John/'))\\n\\n    def test_len(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual(2, len(self.router))\\n\\n    def test_iter(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual({'name1', 'name2'}, set(iter(self.router)))\\n\\n    def test_contains(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertIn('name1', self.router)\\n        self.assertNotIn('name3', self.router)\\n\\n    def test_plain_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<PlainRoute 'name' \\\\[GET\\\\] /get/path\\\")\\n\\n    def test_dynamic_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{path}', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<DynamicRoute 'name' \\\\[GET\\\\] /get/{path}\\\")\\n\\n    def test_static_repr(self):\\n        self.router.add_static('/get', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<StaticRoute 'name' \\\\[GET\\\\] /get/\\\")\\n\\n    def test_static_adds_slash(self):\\n        route = self.router.add_static('/prefix',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_static_dont_add_trailing_slash(self):\\n        route = self.router.add_static('/prefix/',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_add_route_with_re(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/1234')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{name}.html', handler)\\n        req = self.make_request('GET', '/handler/test.html')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertEqual({'name': 'test'}, info)\\n\\n    def test_add_route_with_re_and_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:[^/]+/?}', handler)\\n        req = self.make_request('GET', '/handler/1234/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{to:.+}', handler)\\n        req = self.make_request('GET', '/handler/1234/5/6/7')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/5/6/7'}, info)\\n\\n    def test_add_route_with_re_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/tail')\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n        with self.assertRaises(HTTPNotFound):\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n    def test_add_route_with_re_including_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:.+}/tail', handler)\\n        req = self.make_request('GET', '/handler/re/with/slashes/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 're/with/slashes'}, info)\\n\\n    def test_add_route_with_invalid_re(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError) as ctx:\\n            self.router.add_route('GET', r'/handler/{to:+++}', handler)\\n        s = str(ctx.exception)\\n        self.assertTrue(s.startswith(\\n            \\\"Bad pattern '\\\\/handler\\\\/(?P<to>+++)': nothing to repeat\\\"), s)\\n        self.assertIsNone(ctx.exception.__cause__)\\n\\n    def test_route_dynamic_with_regex_spec(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123', url)\\n\\n    def test_route_dynamic_with_regex_spec_and_trailing_slash(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}/', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123/', url)\\n\\n    def test_route_dynamic_with_regex(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', r'/{one}/{two:.+}', handler)\\n\\n        url = route.url(parts={'one': 1, 'two': 2})\\n        self.assertEqual('/1/2', url)\\n\\n    def test_regular_match_info(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/get/{name}', handler)\\n\\n            req = self.make_request('GET', '/get/john')\\n            match_info = yield from self.router.resolve(req)\\n            self.maxDiff = None\\n            self.assertRegex(repr(match_info),\\n                             \\\"<MatchInfo {'name': 'john'}: <DynamicRoute.+>>\\\")\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_found_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            req = self.make_request('POST', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: not found>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_allowed_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/path/to', handler)\\n\\n            handler2 = self.make_handler()\\n            self.router.add_route('POST', '/path/to', handler2)\\n\\n            req = self.make_request('PUT', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: method PUT is not allowed \\\"\\n                             \\\"(allowed methods: GET, POST>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_default_expect_handler(self):\\n        route = self.router.add_route('GET', '/', self.make_handler())\\n        self.assertIs(route._expect_handler, _defaultExpectHandler)\\n\\n    def test_custom_expect_handler_plain(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, PlainRoute)\\n\\n    def test_custom_expect_handler_dynamic(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/get/{name}', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, DynamicRoute)\\n\\n    def test_expect_handler_non_coroutine(self):\\n\\n        def handler(request):\\n            pass\\n\\n        self.assertRaises(\\n            AssertionError, self.router.add_route,\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n\\n    def test_dynamic_match_non_ascii(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{var}', handler)\\n            req = self.make_request(\\n                'GET',\\n                '/%D1%80%D1%83%D1%81%20%D1%82%D0%B5%D0%BA%D1%81%D1%82')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'var': '\u0440\u0443\u0441 \u0442\u0435\u043a\u0441\u0442'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_with_static_part(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.html', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_two_part2(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.{ext}', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file', 'ext': 'html'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_unquoted_path(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{path}/{subpath}', handler)\\n            resource_id = 'my%2Fpath%7Cwith%21some%25strange%24characters'\\n            req = self.make_request('GET', '/path/{0}'.format(resource_id))\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(match_info, {\\n                'path': 'path',\\n                'subpath': unquote(resource_id)\\n            })\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_add_route_not_started_with_slash(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('GET', 'invalid_path', handler)\\n\\n    def test_add_route_invalid_method(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('INVALID_METHOD', '/path', handler)\\n\\n    def test_static_handle_eof(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.return_value = 0\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIsNone(fut.result())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_again(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.side_effect = BlockingIOError()\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertFalse(fut.done())\\n            loop.add_writer.assert_called_with(out_fd, route._sendfile_cb,\\n                                               fut, out_fd, in_fd, 0, 100,\\n                                               loop, True)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_exception(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            exc = OSError()\\n            m_os.sendfile.side_effect = exc\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIs(exc, fut.exception())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def fill_routes(self):\\n        route1 = self.router.add_route('GET', '/plain', self.make_handler())\\n        route2 = self.router.add_route('GET', '/variable/{name}',\\n                                       self.make_handler())\\n        route3 = self.router.add_static('/static',\\n                                        os.path.dirname(aiohttp.__file__))\\n        return route1, route2, route3\\n\\n    def test_routes_view_len(self):\\n        self.fill_routes()\\n        self.assertEqual(3, len(self.router.routes()))\\n\\n    def test_routes_view_iter(self):\\n        routes = self.fill_routes()\\n        self.assertEqual(list(routes), list(self.router.routes()))\\n\\n    def test_routes_view_contains(self):\\n        routes = self.fill_routes()\\n        for route in routes:\\n            self.assertIn(route, self.router.routes())\\n\\n    def test_routes_abc(self):\\n        self.assertIsInstance(self.router.routes(), Sized)\\n        self.assertIsInstance(self.router.routes(), Iterable)\\n        self.assertIsInstance(self.router.routes(), Container)\\n\",\n            \"new_file_content\": \"import asyncio\\nimport os\\nimport unittest\\nfrom collections.abc import Sized, Container, Iterable\\nfrom unittest import mock\\nfrom urllib.parse import unquote\\nimport aiohttp.web\\nfrom aiohttp import hdrs\\nfrom aiohttp.web import (UrlDispatcher, Request, Response,\\n                         HTTPMethodNotAllowed, HTTPNotFound)\\nfrom aiohttp.multidict import CIMultiDict\\nfrom aiohttp.protocol import HttpVersion, RawRequestMessage\\nfrom aiohttp.web_urldispatcher import (_defaultExpectHandler,\\n                                       DynamicRoute,\\n                                       PlainRoute,\\n                                       SystemRoute)\\n\\n\\nclass TestUrlDispatcher(unittest.TestCase):\\n\\n    def setUp(self):\\n        self.loop = asyncio.new_event_loop()\\n        asyncio.set_event_loop(None)\\n        self.router = UrlDispatcher()\\n\\n    def tearDown(self):\\n        self.loop.close()\\n\\n    def make_request(self, method, path):\\n        self.app = mock.Mock()\\n        message = RawRequestMessage(method, path, HttpVersion(1, 1),\\n                                    CIMultiDict(), False, False)\\n        self.payload = mock.Mock()\\n        self.transport = mock.Mock()\\n        self.reader = mock.Mock()\\n        self.writer = mock.Mock()\\n        req = Request(self.app, message, self.payload,\\n                      self.transport, self.reader, self.writer)\\n        return req\\n\\n    def make_handler(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            return Response(request)  # pragma: no cover\\n\\n        return handler\\n\\n    def test_system_route(self):\\n        route = SystemRoute(201, 'test')\\n        self.assertIsNone(route.match('any'))\\n        with self.assertRaises(RuntimeError):\\n            route.url()\\n        self.assertEqual(\\\"<SystemRoute 201: test>\\\", repr(route))\\n        self.assertEqual(201, route.status)\\n        self.assertEqual('test', route.reason)\\n\\n    def test_register_route(self):\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(route, info.route)\\n        self.assertIs(handler, info.handler)\\n        self.assertEqual(info.route.name, 'test')\\n\\n    def test_register_route_checks(self):\\n        self.assertRaises(\\n            AssertionError, self.router.register_route, object())\\n\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, '1bad name', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, 'return', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, 'test.test:test',\\n                           '/handler/to/path')\\n        self.router.register_route(route)\\n\\n    def test_add_route_root(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/', handler)\\n        req = self.make_request('GET', '/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_route_simple(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler)\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_matchdict(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/{to}', handler)\\n        req = self.make_request('GET', '/handler/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 'tail'}, info)\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_name(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler,\\n                              name='name')\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual('name', info.route.name)\\n\\n    def test_add_with_tailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path/', handler)\\n        req = self.make_request('GET', '/handler/to/path/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_add_invalid_path(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('GET', '/{/', handler)\\n\\n    def test_add_url_invalid1(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id', handler)\\n\\n    def test_add_url_invalid2(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}}', handler)\\n\\n    def test_add_url_invalid3(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}', handler)\\n\\n    def test_add_url_invalid4(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id\\\"}', handler)\\n\\n    def test_add_url_escaping(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/+$', handler)\\n\\n        req = self.make_request('GET', '/+$')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_any_method(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route(hdrs.METH_ANY, '/', handler)\\n\\n        req = self.make_request('GET', '/')\\n        info1 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info1)\\n        self.assertIs(route, info1.route)\\n\\n        req = self.make_request('POST', '/')\\n        info2 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info2)\\n\\n        self.assertIs(info1.route, info2.route)\\n\\n    def test_match_second_result_in_table(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/h1', handler1)\\n        self.router.add_route('POST', '/h2', handler2)\\n        req = self.make_request('POST', '/h2')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler2, info.handler)\\n\\n    def test_raise_method_not_allowed(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/', handler1)\\n        self.router.add_route('POST', '/', handler2)\\n        req = self.make_request('PUT', '/')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPMethodNotAllowed) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual('PUT', exc.method)\\n        self.assertEqual(405, exc.status)\\n        self.assertEqual({'POST', 'GET'}, exc.allowed_methods)\\n\\n    def test_raise_method_not_found(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/a', handler)\\n        req = self.make_request('GET', '/b')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPNotFound) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual(404, exc.status)\\n\\n    def test_double_add_url_with_the_same_name(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/get', handler1, name='name')\\n\\n        regexp = (\\\"Duplicate 'name', already handled by\\\")\\n        with self.assertRaisesRegex(ValueError, regexp):\\n            self.router.add_route('GET', '/get_other', handler2, name='name')\\n\\n    def test_route_plain(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get', handler, name='name')\\n        route2 = self.router['name']\\n        url = route2.url()\\n        self.assertEqual('/get', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_unknown_route_name(self):\\n        with self.assertRaises(KeyError):\\n            self.router['unknown']\\n\\n    def test_route_dynamic(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{name}', handler,\\n                                      name='name')\\n\\n        route2 = self.router['name']\\n        url = route2.url(parts={'name': 'John'})\\n        self.assertEqual('/get/John', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_with_qs(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get', handler, name='name')\\n\\n        url = self.router['name'].url(query=[('a', 'b'), ('c', 1)])\\n        self.assertEqual('/get?a=b&c=1', url)\\n\\n    def test_add_static(self):\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__),\\n                                       name='static')\\n        route2 = self.router['static']\\n        url = route2.url(filename='/dir/a.txt')\\n        self.assertEqual('/st/dir/a.txt', url)\\n        self.assertIs(route, route2)\\n\\n    def test_plain_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_static_not_match(self):\\n        self.router.add_static('/pre', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_with_trailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}/', handler, name='name')\\n        route = self.router['name']\\n        self.assertEqual({'name': 'John'}, route.match('/get/John/'))\\n\\n    def test_len(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual(2, len(self.router))\\n\\n    def test_iter(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual({'name1', 'name2'}, set(iter(self.router)))\\n\\n    def test_contains(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertIn('name1', self.router)\\n        self.assertNotIn('name3', self.router)\\n\\n    def test_plain_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<PlainRoute 'name' \\\\[GET\\\\] /get/path\\\")\\n\\n    def test_dynamic_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{path}', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<DynamicRoute 'name' \\\\[GET\\\\] /get/{path}\\\")\\n\\n    def test_static_repr(self):\\n        self.router.add_static('/get', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<StaticRoute 'name' \\\\[GET\\\\] /get/\\\")\\n\\n    def test_static_adds_slash(self):\\n        route = self.router.add_static('/prefix',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_static_dont_add_trailing_slash(self):\\n        route = self.router.add_static('/prefix/',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_add_route_with_re(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/1234')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{name}.html', handler)\\n        req = self.make_request('GET', '/handler/test.html')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertEqual({'name': 'test'}, info)\\n\\n    def test_add_route_with_re_and_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:[^/]+/?}', handler)\\n        req = self.make_request('GET', '/handler/1234/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{to:.+}', handler)\\n        req = self.make_request('GET', '/handler/1234/5/6/7')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/5/6/7'}, info)\\n\\n    def test_add_route_with_re_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/tail')\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n        with self.assertRaises(HTTPNotFound):\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n    def test_add_route_with_re_including_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:.+}/tail', handler)\\n        req = self.make_request('GET', '/handler/re/with/slashes/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 're/with/slashes'}, info)\\n\\n    def test_add_route_with_invalid_re(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError) as ctx:\\n            self.router.add_route('GET', r'/handler/{to:+++}', handler)\\n        s = str(ctx.exception)\\n        self.assertTrue(s.startswith(\\n            \\\"Bad pattern '\\\\/handler\\\\/(?P<to>+++)': nothing to repeat\\\"), s)\\n        self.assertIsNone(ctx.exception.__cause__)\\n\\n    def test_route_dynamic_with_regex_spec(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123', url)\\n\\n    def test_route_dynamic_with_regex_spec_and_trailing_slash(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}/', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123/', url)\\n\\n    def test_route_dynamic_with_regex(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', r'/{one}/{two:.+}', handler)\\n\\n        url = route.url(parts={'one': 1, 'two': 2})\\n        self.assertEqual('/1/2', url)\\n\\n    def test_regular_match_info(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/get/{name}', handler)\\n\\n            req = self.make_request('GET', '/get/john')\\n            match_info = yield from self.router.resolve(req)\\n            self.maxDiff = None\\n            self.assertRegex(repr(match_info),\\n                             \\\"<MatchInfo {'name': 'john'}: <DynamicRoute.+>>\\\")\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_found_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            req = self.make_request('POST', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: not found>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_allowed_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/path/to', handler)\\n\\n            handler2 = self.make_handler()\\n            self.router.add_route('POST', '/path/to', handler2)\\n\\n            req = self.make_request('PUT', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: method PUT is not allowed \\\"\\n                             \\\"(allowed methods: GET, POST>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_default_expect_handler(self):\\n        route = self.router.add_route('GET', '/', self.make_handler())\\n        self.assertIs(route._expect_handler, _defaultExpectHandler)\\n\\n    def test_custom_expect_handler_plain(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, PlainRoute)\\n\\n    def test_custom_expect_handler_dynamic(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/get/{name}', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, DynamicRoute)\\n\\n    def test_expect_handler_non_coroutine(self):\\n\\n        def handler(request):\\n            pass\\n\\n        self.assertRaises(\\n            AssertionError, self.router.add_route,\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n\\n    def test_dynamic_match_non_ascii(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{var}', handler)\\n            req = self.make_request(\\n                'GET',\\n                '/%D1%80%D1%83%D1%81%20%D1%82%D0%B5%D0%BA%D1%81%D1%82')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'var': '\u0440\u0443\u0441 \u0442\u0435\u043a\u0441\u0442'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_with_static_part(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.html', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_two_part2(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.{ext}', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file', 'ext': 'html'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_unquoted_path(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{path}/{subpath}', handler)\\n            resource_id = 'my%2Fpath%7Cwith%21some%25strange%24characters'\\n            req = self.make_request('GET', '/path/{0}'.format(resource_id))\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(match_info, {\\n                'path': 'path',\\n                'subpath': unquote(resource_id)\\n            })\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_add_route_not_started_with_slash(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('GET', 'invalid_path', handler)\\n\\n    def test_add_route_invalid_method(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('INVALID_METHOD', '/path', handler)\\n\\n    def test_static_handle_eof(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.return_value = 0\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIsNone(fut.result())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_again(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.side_effect = BlockingIOError()\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertFalse(fut.done())\\n            loop.add_writer.assert_called_with(out_fd, route._sendfile_cb,\\n                                               fut, out_fd, in_fd, 0, 100,\\n                                               loop, True)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_exception(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            exc = OSError()\\n            m_os.sendfile.side_effect = exc\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIs(exc, fut.exception())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def fill_routes(self):\\n        route1 = self.router.add_route('GET', '/plain', self.make_handler())\\n        route2 = self.router.add_route('GET', '/variable/{name}',\\n                                       self.make_handler())\\n        route3 = self.router.add_static('/static',\\n                                        os.path.dirname(aiohttp.__file__))\\n        return route1, route2, route3\\n\\n    def test_routes_view_len(self):\\n        self.fill_routes()\\n        self.assertEqual(3, len(self.router.routes()))\\n\\n    def test_routes_view_iter(self):\\n        routes = self.fill_routes()\\n        self.assertEqual(list(routes), list(self.router.routes()))\\n\\n    def test_routes_view_contains(self):\\n        routes = self.fill_routes()\\n        for route in routes:\\n            self.assertIn(route, self.router.routes())\\n\\n    def test_routes_abc(self):\\n        self.assertIsInstance(self.router.routes(), Sized)\\n        self.assertIsInstance(self.router.routes(), Iterable)\\n        self.assertIsInstance(self.router.routes(), Container)\\n\",\n            \"header\": {\n                \"file\": {\n                    \"path\": \"tests/test_urldispatch.py\"\n                },\n                \"misc_line\": null\n            },\n            \"index_line\": {\n                \"old_commit_hash\": \"fd5e6848\",\n                \"new_commit_hash\": \"72f74440\",\n                \"mode\": \"100644\"\n            },\n            \"is_binary_file\": false,\n            \"binary_line\": null,\n            \"minus_file\": {\n                \"path\": \"a/tests/test_urldispatch.py\"\n            },\n            \"plus_file\": {\n                \"path\": \"b/tests/test_urldispatch.py\"\n            },\n            \"hunks\": [\n                {\n                    \"descriptor\": {\n                        \"old_range\": {\n                            \"start\": 83,\n                            \"length\": 6\n                        },\n                        \"new_range\": {\n                            \"start\": 83,\n                            \"length\": 10\n                        },\n                        \"section\": \"class TestUrlDispatcher(unittest.TestCase):\"\n                    },\n                    \"line_group\": {\n                        \"all_lines\": [\n                            {\n                                \"content\": \"        route = PlainRoute('GET', handler, 'return', '/handler/to/path')\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"        self.assertRaises(ValueError, self.router.register_route, route)\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"        route = PlainRoute('GET', handler, 'test.test:test',\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"                           '/handler/to/path')\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"        self.router.register_route(route)\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"\",\n                                \"type\": \"added\"\n                            },\n                            {\n                                \"content\": \"    def test_add_route_root(self):\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"        handler = self.make_handler()\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"        self.router.add_route('GET', '/', handler)\",\n                                \"type\": \"context\"\n                            },\n                            {\n                                \"content\": \"\",\n                                \"type\": \"context\"\n                            }\n                        ]\n                    },\n                    \"modified_entities\": [\n                        {\n                            \"file_name\": \"tests/test_urldispatch.py\",\n                            \"type\": \"method\",\n                            \"name\": \"TestUrlDispatcher.test_register_route_checks\",\n                            \"content\": \"class TestUrlDispatcher(unittest.TestCase):\\n\\n    def setUp(self):\\n        self.loop = asyncio.new_event_loop()\\n        asyncio.set_event_loop(None)\\n        self.router = UrlDispatcher()\\n\\n    def tearDown(self):\\n        self.loop.close()\\n\\n    def make_request(self, method, path):\\n        self.app = mock.Mock()\\n        message = RawRequestMessage(method, path, HttpVersion(1, 1),\\n                                    CIMultiDict(), False, False)\\n        self.payload = mock.Mock()\\n        self.transport = mock.Mock()\\n        self.reader = mock.Mock()\\n        self.writer = mock.Mock()\\n        req = Request(self.app, message, self.payload,\\n                      self.transport, self.reader, self.writer)\\n        return req\\n\\n    def make_handler(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            return Response(request)  # pragma: no cover\\n\\n        return handler\\n\\n    def test_system_route(self):\\n        route = SystemRoute(201, 'test')\\n        self.assertIsNone(route.match('any'))\\n        with self.assertRaises(RuntimeError):\\n            route.url()\\n        self.assertEqual(\\\"<SystemRoute 201: test>\\\", repr(route))\\n        self.assertEqual(201, route.status)\\n        self.assertEqual('test', route.reason)\\n\\n    def test_register_route(self):\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(route, info.route)\\n        self.assertIs(handler, info.handler)\\n        self.assertEqual(info.route.name, 'test')\\n\\n    def test_register_route_checks(self):\\n        self.assertRaises(\\n            AssertionError, self.router.register_route, object())\\n\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, '1bad name', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, 'return', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, 'test.test:test',\\n                           '/handler/to/path')\\n        self.router.register_route(route)\\n\\n    def test_add_route_root(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/', handler)\\n        req = self.make_request('GET', '/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_route_simple(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler)\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_matchdict(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/{to}', handler)\\n        req = self.make_request('GET', '/handler/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 'tail'}, info)\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_name(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler,\\n                              name='name')\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual('name', info.route.name)\\n\\n    def test_add_with_tailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path/', handler)\\n        req = self.make_request('GET', '/handler/to/path/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_add_invalid_path(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('GET', '/{/', handler)\\n\\n    def test_add_url_invalid1(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id', handler)\\n\\n    def test_add_url_invalid2(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}}', handler)\\n\\n    def test_add_url_invalid3(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}', handler)\\n\\n    def test_add_url_invalid4(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id\\\"}', handler)\\n\\n    def test_add_url_escaping(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/+$', handler)\\n\\n        req = self.make_request('GET', '/+$')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_any_method(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route(hdrs.METH_ANY, '/', handler)\\n\\n        req = self.make_request('GET', '/')\\n        info1 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info1)\\n        self.assertIs(route, info1.route)\\n\\n        req = self.make_request('POST', '/')\\n        info2 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info2)\\n\\n        self.assertIs(info1.route, info2.route)\\n\\n    def test_match_second_result_in_table(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/h1', handler1)\\n        self.router.add_route('POST', '/h2', handler2)\\n        req = self.make_request('POST', '/h2')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler2, info.handler)\\n\\n    def test_raise_method_not_allowed(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/', handler1)\\n        self.router.add_route('POST', '/', handler2)\\n        req = self.make_request('PUT', '/')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPMethodNotAllowed) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual('PUT', exc.method)\\n        self.assertEqual(405, exc.status)\\n        self.assertEqual({'POST', 'GET'}, exc.allowed_methods)\\n\\n    def test_raise_method_not_found(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/a', handler)\\n        req = self.make_request('GET', '/b')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPNotFound) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual(404, exc.status)\\n\\n    def test_double_add_url_with_the_same_name(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/get', handler1, name='name')\\n\\n        regexp = (\\\"Duplicate 'name', already handled by\\\")\\n        with self.assertRaisesRegex(ValueError, regexp):\\n            self.router.add_route('GET', '/get_other', handler2, name='name')\\n\\n    def test_route_plain(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get', handler, name='name')\\n        route2 = self.router['name']\\n        url = route2.url()\\n        self.assertEqual('/get', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_unknown_route_name(self):\\n        with self.assertRaises(KeyError):\\n            self.router['unknown']\\n\\n    def test_route_dynamic(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{name}', handler,\\n                                      name='name')\\n\\n        route2 = self.router['name']\\n        url = route2.url(parts={'name': 'John'})\\n        self.assertEqual('/get/John', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_with_qs(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get', handler, name='name')\\n\\n        url = self.router['name'].url(query=[('a', 'b'), ('c', 1)])\\n        self.assertEqual('/get?a=b&c=1', url)\\n\\n    def test_add_static(self):\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__),\\n                                       name='static')\\n        route2 = self.router['static']\\n        url = route2.url(filename='/dir/a.txt')\\n        self.assertEqual('/st/dir/a.txt', url)\\n        self.assertIs(route, route2)\\n\\n    def test_plain_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_static_not_match(self):\\n        self.router.add_static('/pre', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_with_trailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}/', handler, name='name')\\n        route = self.router['name']\\n        self.assertEqual({'name': 'John'}, route.match('/get/John/'))\\n\\n    def test_len(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual(2, len(self.router))\\n\\n    def test_iter(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual({'name1', 'name2'}, set(iter(self.router)))\\n\\n    def test_contains(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertIn('name1', self.router)\\n        self.assertNotIn('name3', self.router)\\n\\n    def test_plain_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<PlainRoute 'name' \\\\[GET\\\\] /get/path\\\")\\n\\n    def test_dynamic_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{path}', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<DynamicRoute 'name' \\\\[GET\\\\] /get/{path}\\\")\\n\\n    def test_static_repr(self):\\n        self.router.add_static('/get', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<StaticRoute 'name' \\\\[GET\\\\] /get/\\\")\\n\\n    def test_static_adds_slash(self):\\n        route = self.router.add_static('/prefix',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_static_dont_add_trailing_slash(self):\\n        route = self.router.add_static('/prefix/',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_add_route_with_re(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/1234')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{name}.html', handler)\\n        req = self.make_request('GET', '/handler/test.html')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertEqual({'name': 'test'}, info)\\n\\n    def test_add_route_with_re_and_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:[^/]+/?}', handler)\\n        req = self.make_request('GET', '/handler/1234/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{to:.+}', handler)\\n        req = self.make_request('GET', '/handler/1234/5/6/7')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/5/6/7'}, info)\\n\\n    def test_add_route_with_re_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/tail')\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n        with self.assertRaises(HTTPNotFound):\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n    def test_add_route_with_re_including_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:.+}/tail', handler)\\n        req = self.make_request('GET', '/handler/re/with/slashes/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 're/with/slashes'}, info)\\n\\n    def test_add_route_with_invalid_re(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError) as ctx:\\n            self.router.add_route('GET', r'/handler/{to:+++}', handler)\\n        s = str(ctx.exception)\\n        self.assertTrue(s.startswith(\\n            \\\"Bad pattern '\\\\/handler\\\\/(?P<to>+++)': nothing to repeat\\\"), s)\\n        self.assertIsNone(ctx.exception.__cause__)\\n\\n    def test_route_dynamic_with_regex_spec(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123', url)\\n\\n    def test_route_dynamic_with_regex_spec_and_trailing_slash(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}/', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123/', url)\\n\\n    def test_route_dynamic_with_regex(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', r'/{one}/{two:.+}', handler)\\n\\n        url = route.url(parts={'one': 1, 'two': 2})\\n        self.assertEqual('/1/2', url)\\n\\n    def test_regular_match_info(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/get/{name}', handler)\\n\\n            req = self.make_request('GET', '/get/john')\\n            match_info = yield from self.router.resolve(req)\\n            self.maxDiff = None\\n            self.assertRegex(repr(match_info),\\n                             \\\"<MatchInfo {'name': 'john'}: <DynamicRoute.+>>\\\")\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_found_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            req = self.make_request('POST', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: not found>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_allowed_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/path/to', handler)\\n\\n            handler2 = self.make_handler()\\n            self.router.add_route('POST', '/path/to', handler2)\\n\\n            req = self.make_request('PUT', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: method PUT is not allowed \\\"\\n                             \\\"(allowed methods: GET, POST>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_default_expect_handler(self):\\n        route = self.router.add_route('GET', '/', self.make_handler())\\n        self.assertIs(route._expect_handler, _defaultExpectHandler)\\n\\n    def test_custom_expect_handler_plain(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, PlainRoute)\\n\\n    def test_custom_expect_handler_dynamic(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/get/{name}', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, DynamicRoute)\\n\\n    def test_expect_handler_non_coroutine(self):\\n\\n        def handler(request):\\n            pass\\n\\n        self.assertRaises(\\n            AssertionError, self.router.add_route,\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n\\n    def test_dynamic_match_non_ascii(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{var}', handler)\\n            req = self.make_request(\\n                'GET',\\n                '/%D1%80%D1%83%D1%81%20%D1%82%D0%B5%D0%BA%D1%81%D1%82')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'var': '\u0440\u0443\u0441 \u0442\u0435\u043a\u0441\u0442'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_with_static_part(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.html', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_two_part2(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.{ext}', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file', 'ext': 'html'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_unquoted_path(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{path}/{subpath}', handler)\\n            resource_id = 'my%2Fpath%7Cwith%21some%25strange%24characters'\\n            req = self.make_request('GET', '/path/{0}'.format(resource_id))\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(match_info, {\\n                'path': 'path',\\n                'subpath': unquote(resource_id)\\n            })\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_add_route_not_started_with_slash(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('GET', 'invalid_path', handler)\\n\\n    def test_add_route_invalid_method(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('INVALID_METHOD', '/path', handler)\\n\\n    def test_static_handle_eof(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.return_value = 0\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIsNone(fut.result())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_again(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.side_effect = BlockingIOError()\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertFalse(fut.done())\\n            loop.add_writer.assert_called_with(out_fd, route._sendfile_cb,\\n                                               fut, out_fd, in_fd, 0, 100,\\n                                               loop, True)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_exception(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            exc = OSError()\\n            m_os.sendfile.side_effect = exc\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIs(exc, fut.exception())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def fill_routes(self):\\n        route1 = self.router.add_route('GET', '/plain', self.make_handler())\\n        route2 = self.router.add_route('GET', '/variable/{name}',\\n                                       self.make_handler())\\n        route3 = self.router.add_static('/static',\\n                                        os.path.dirname(aiohttp.__file__))\\n        return route1, route2, route3\\n\\n    def test_routes_view_len(self):\\n        self.fill_routes()\\n        self.assertEqual(3, len(self.router.routes()))\\n\\n    def test_routes_view_iter(self):\\n        routes = self.fill_routes()\\n        self.assertEqual(list(routes), list(self.router.routes()))\\n\\n    def test_routes_view_contains(self):\\n        routes = self.fill_routes()\\n        for route in routes:\\n            self.assertIn(route, self.router.routes())\\n\\n    def test_routes_abc(self):\\n        self.assertIsInstance(self.router.routes(), Sized)\\n        self.assertIsInstance(self.router.routes(), Iterable)\\n        self.assertIsInstance(self.router.routes(), Container)\",\n                            \"ast_type_str\": \"ClassDef\",\n                            \"start_lineno\": 71,\n                            \"end_lineno\": 88,\n                            \"parent\": {\n                                \"file_name\": \"tests/test_urldispatch.py\",\n                                \"type\": \"class\",\n                                \"name\": \"TestUrlDispatcher\",\n                                \"content\": \"class TestUrlDispatcher(unittest.TestCase):\\n\\n    def setUp(self):\\n        self.loop = asyncio.new_event_loop()\\n        asyncio.set_event_loop(None)\\n        self.router = UrlDispatcher()\\n\\n    def tearDown(self):\\n        self.loop.close()\\n\\n    def make_request(self, method, path):\\n        self.app = mock.Mock()\\n        message = RawRequestMessage(method, path, HttpVersion(1, 1),\\n                                    CIMultiDict(), False, False)\\n        self.payload = mock.Mock()\\n        self.transport = mock.Mock()\\n        self.reader = mock.Mock()\\n        self.writer = mock.Mock()\\n        req = Request(self.app, message, self.payload,\\n                      self.transport, self.reader, self.writer)\\n        return req\\n\\n    def make_handler(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            return Response(request)  # pragma: no cover\\n\\n        return handler\\n\\n    def test_system_route(self):\\n        route = SystemRoute(201, 'test')\\n        self.assertIsNone(route.match('any'))\\n        with self.assertRaises(RuntimeError):\\n            route.url()\\n        self.assertEqual(\\\"<SystemRoute 201: test>\\\", repr(route))\\n        self.assertEqual(201, route.status)\\n        self.assertEqual('test', route.reason)\\n\\n    def test_register_route(self):\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(route, info.route)\\n        self.assertIs(handler, info.handler)\\n        self.assertEqual(info.route.name, 'test')\\n\\n    def test_register_route_checks(self):\\n        self.assertRaises(\\n            AssertionError, self.router.register_route, object())\\n\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, '1bad name', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, 'return', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, 'test.test:test',\\n                           '/handler/to/path')\\n        self.router.register_route(route)\\n\\n    def test_add_route_root(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/', handler)\\n        req = self.make_request('GET', '/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_route_simple(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler)\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_matchdict(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/{to}', handler)\\n        req = self.make_request('GET', '/handler/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 'tail'}, info)\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_name(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler,\\n                              name='name')\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual('name', info.route.name)\\n\\n    def test_add_with_tailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path/', handler)\\n        req = self.make_request('GET', '/handler/to/path/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_add_invalid_path(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('GET', '/{/', handler)\\n\\n    def test_add_url_invalid1(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id', handler)\\n\\n    def test_add_url_invalid2(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}}', handler)\\n\\n    def test_add_url_invalid3(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}', handler)\\n\\n    def test_add_url_invalid4(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id\\\"}', handler)\\n\\n    def test_add_url_escaping(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/+$', handler)\\n\\n        req = self.make_request('GET', '/+$')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_any_method(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route(hdrs.METH_ANY, '/', handler)\\n\\n        req = self.make_request('GET', '/')\\n        info1 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info1)\\n        self.assertIs(route, info1.route)\\n\\n        req = self.make_request('POST', '/')\\n        info2 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info2)\\n\\n        self.assertIs(info1.route, info2.route)\\n\\n    def test_match_second_result_in_table(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/h1', handler1)\\n        self.router.add_route('POST', '/h2', handler2)\\n        req = self.make_request('POST', '/h2')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler2, info.handler)\\n\\n    def test_raise_method_not_allowed(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/', handler1)\\n        self.router.add_route('POST', '/', handler2)\\n        req = self.make_request('PUT', '/')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPMethodNotAllowed) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual('PUT', exc.method)\\n        self.assertEqual(405, exc.status)\\n        self.assertEqual({'POST', 'GET'}, exc.allowed_methods)\\n\\n    def test_raise_method_not_found(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/a', handler)\\n        req = self.make_request('GET', '/b')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPNotFound) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual(404, exc.status)\\n\\n    def test_double_add_url_with_the_same_name(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/get', handler1, name='name')\\n\\n        regexp = (\\\"Duplicate 'name', already handled by\\\")\\n        with self.assertRaisesRegex(ValueError, regexp):\\n            self.router.add_route('GET', '/get_other', handler2, name='name')\\n\\n    def test_route_plain(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get', handler, name='name')\\n        route2 = self.router['name']\\n        url = route2.url()\\n        self.assertEqual('/get', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_unknown_route_name(self):\\n        with self.assertRaises(KeyError):\\n            self.router['unknown']\\n\\n    def test_route_dynamic(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{name}', handler,\\n                                      name='name')\\n\\n        route2 = self.router['name']\\n        url = route2.url(parts={'name': 'John'})\\n        self.assertEqual('/get/John', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_with_qs(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get', handler, name='name')\\n\\n        url = self.router['name'].url(query=[('a', 'b'), ('c', 1)])\\n        self.assertEqual('/get?a=b&c=1', url)\\n\\n    def test_add_static(self):\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__),\\n                                       name='static')\\n        route2 = self.router['static']\\n        url = route2.url(filename='/dir/a.txt')\\n        self.assertEqual('/st/dir/a.txt', url)\\n        self.assertIs(route, route2)\\n\\n    def test_plain_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_static_not_match(self):\\n        self.router.add_static('/pre', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_with_trailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}/', handler, name='name')\\n        route = self.router['name']\\n        self.assertEqual({'name': 'John'}, route.match('/get/John/'))\\n\\n    def test_len(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual(2, len(self.router))\\n\\n    def test_iter(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual({'name1', 'name2'}, set(iter(self.router)))\\n\\n    def test_contains(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertIn('name1', self.router)\\n        self.assertNotIn('name3', self.router)\\n\\n    def test_plain_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<PlainRoute 'name' \\\\[GET\\\\] /get/path\\\")\\n\\n    def test_dynamic_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{path}', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<DynamicRoute 'name' \\\\[GET\\\\] /get/{path}\\\")\\n\\n    def test_static_repr(self):\\n        self.router.add_static('/get', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<StaticRoute 'name' \\\\[GET\\\\] /get/\\\")\\n\\n    def test_static_adds_slash(self):\\n        route = self.router.add_static('/prefix',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_static_dont_add_trailing_slash(self):\\n        route = self.router.add_static('/prefix/',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_add_route_with_re(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/1234')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{name}.html', handler)\\n        req = self.make_request('GET', '/handler/test.html')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertEqual({'name': 'test'}, info)\\n\\n    def test_add_route_with_re_and_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:[^/]+/?}', handler)\\n        req = self.make_request('GET', '/handler/1234/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{to:.+}', handler)\\n        req = self.make_request('GET', '/handler/1234/5/6/7')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/5/6/7'}, info)\\n\\n    def test_add_route_with_re_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/tail')\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n        with self.assertRaises(HTTPNotFound):\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n    def test_add_route_with_re_including_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:.+}/tail', handler)\\n        req = self.make_request('GET', '/handler/re/with/slashes/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 're/with/slashes'}, info)\\n\\n    def test_add_route_with_invalid_re(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError) as ctx:\\n            self.router.add_route('GET', r'/handler/{to:+++}', handler)\\n        s = str(ctx.exception)\\n        self.assertTrue(s.startswith(\\n            \\\"Bad pattern '\\\\/handler\\\\/(?P<to>+++)': nothing to repeat\\\"), s)\\n        self.assertIsNone(ctx.exception.__cause__)\\n\\n    def test_route_dynamic_with_regex_spec(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123', url)\\n\\n    def test_route_dynamic_with_regex_spec_and_trailing_slash(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}/', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123/', url)\\n\\n    def test_route_dynamic_with_regex(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', r'/{one}/{two:.+}', handler)\\n\\n        url = route.url(parts={'one': 1, 'two': 2})\\n        self.assertEqual('/1/2', url)\\n\\n    def test_regular_match_info(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/get/{name}', handler)\\n\\n            req = self.make_request('GET', '/get/john')\\n            match_info = yield from self.router.resolve(req)\\n            self.maxDiff = None\\n            self.assertRegex(repr(match_info),\\n                             \\\"<MatchInfo {'name': 'john'}: <DynamicRoute.+>>\\\")\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_found_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            req = self.make_request('POST', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: not found>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_allowed_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/path/to', handler)\\n\\n            handler2 = self.make_handler()\\n            self.router.add_route('POST', '/path/to', handler2)\\n\\n            req = self.make_request('PUT', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: method PUT is not allowed \\\"\\n                             \\\"(allowed methods: GET, POST>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_default_expect_handler(self):\\n        route = self.router.add_route('GET', '/', self.make_handler())\\n        self.assertIs(route._expect_handler, _defaultExpectHandler)\\n\\n    def test_custom_expect_handler_plain(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, PlainRoute)\\n\\n    def test_custom_expect_handler_dynamic(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/get/{name}', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, DynamicRoute)\\n\\n    def test_expect_handler_non_coroutine(self):\\n\\n        def handler(request):\\n            pass\\n\\n        self.assertRaises(\\n            AssertionError, self.router.add_route,\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n\\n    def test_dynamic_match_non_ascii(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{var}', handler)\\n            req = self.make_request(\\n                'GET',\\n                '/%D1%80%D1%83%D1%81%20%D1%82%D0%B5%D0%BA%D1%81%D1%82')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'var': '\u0440\u0443\u0441 \u0442\u0435\u043a\u0441\u0442'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_with_static_part(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.html', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_two_part2(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.{ext}', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file', 'ext': 'html'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_unquoted_path(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{path}/{subpath}', handler)\\n            resource_id = 'my%2Fpath%7Cwith%21some%25strange%24characters'\\n            req = self.make_request('GET', '/path/{0}'.format(resource_id))\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(match_info, {\\n                'path': 'path',\\n                'subpath': unquote(resource_id)\\n            })\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_add_route_not_started_with_slash(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('GET', 'invalid_path', handler)\\n\\n    def test_add_route_invalid_method(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('INVALID_METHOD', '/path', handler)\\n\\n    def test_static_handle_eof(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.return_value = 0\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIsNone(fut.result())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_again(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.side_effect = BlockingIOError()\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertFalse(fut.done())\\n            loop.add_writer.assert_called_with(out_fd, route._sendfile_cb,\\n                                               fut, out_fd, in_fd, 0, 100,\\n                                               loop, True)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_exception(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            exc = OSError()\\n            m_os.sendfile.side_effect = exc\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIs(exc, fut.exception())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def fill_routes(self):\\n        route1 = self.router.add_route('GET', '/plain', self.make_handler())\\n        route2 = self.router.add_route('GET', '/variable/{name}',\\n                                       self.make_handler())\\n        route3 = self.router.add_static('/static',\\n                                        os.path.dirname(aiohttp.__file__))\\n        return route1, route2, route3\\n\\n    def test_routes_view_len(self):\\n        self.fill_routes()\\n        self.assertEqual(3, len(self.router.routes()))\\n\\n    def test_routes_view_iter(self):\\n        routes = self.fill_routes()\\n        self.assertEqual(list(routes), list(self.router.routes()))\\n\\n    def test_routes_view_contains(self):\\n        routes = self.fill_routes()\\n        for route in routes:\\n            self.assertIn(route, self.router.routes())\\n\\n    def test_routes_abc(self):\\n        self.assertIsInstance(self.router.routes(), Sized)\\n        self.assertIsInstance(self.router.routes(), Iterable)\\n        self.assertIsInstance(self.router.routes(), Container)\",\n                                \"ast_type_str\": \"ClassDef\",\n                                \"start_lineno\": 19,\n                                \"end_lineno\": 644,\n                                \"parent\": null\n                            }\n                        },\n                        {\n                            \"file_name\": \"tests/test_urldispatch.py\",\n                            \"type\": \"class\",\n                            \"name\": \"TestUrlDispatcher\",\n                            \"content\": \"class TestUrlDispatcher(unittest.TestCase):\\n\\n    def setUp(self):\\n        self.loop = asyncio.new_event_loop()\\n        asyncio.set_event_loop(None)\\n        self.router = UrlDispatcher()\\n\\n    def tearDown(self):\\n        self.loop.close()\\n\\n    def make_request(self, method, path):\\n        self.app = mock.Mock()\\n        message = RawRequestMessage(method, path, HttpVersion(1, 1),\\n                                    CIMultiDict(), False, False)\\n        self.payload = mock.Mock()\\n        self.transport = mock.Mock()\\n        self.reader = mock.Mock()\\n        self.writer = mock.Mock()\\n        req = Request(self.app, message, self.payload,\\n                      self.transport, self.reader, self.writer)\\n        return req\\n\\n    def make_handler(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            return Response(request)  # pragma: no cover\\n\\n        return handler\\n\\n    def test_system_route(self):\\n        route = SystemRoute(201, 'test')\\n        self.assertIsNone(route.match('any'))\\n        with self.assertRaises(RuntimeError):\\n            route.url()\\n        self.assertEqual(\\\"<SystemRoute 201: test>\\\", repr(route))\\n        self.assertEqual(201, route.status)\\n        self.assertEqual('test', route.reason)\\n\\n    def test_register_route(self):\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(route, info.route)\\n        self.assertIs(handler, info.handler)\\n        self.assertEqual(info.route.name, 'test')\\n\\n    def test_register_route_checks(self):\\n        self.assertRaises(\\n            AssertionError, self.router.register_route, object())\\n\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, '1bad name', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, 'return', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, 'test.test:test',\\n                           '/handler/to/path')\\n        self.router.register_route(route)\\n\\n    def test_add_route_root(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/', handler)\\n        req = self.make_request('GET', '/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_route_simple(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler)\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_matchdict(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/{to}', handler)\\n        req = self.make_request('GET', '/handler/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 'tail'}, info)\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_name(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler,\\n                              name='name')\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual('name', info.route.name)\\n\\n    def test_add_with_tailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path/', handler)\\n        req = self.make_request('GET', '/handler/to/path/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_add_invalid_path(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('GET', '/{/', handler)\\n\\n    def test_add_url_invalid1(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id', handler)\\n\\n    def test_add_url_invalid2(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}}', handler)\\n\\n    def test_add_url_invalid3(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}', handler)\\n\\n    def test_add_url_invalid4(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id\\\"}', handler)\\n\\n    def test_add_url_escaping(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/+$', handler)\\n\\n        req = self.make_request('GET', '/+$')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_any_method(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route(hdrs.METH_ANY, '/', handler)\\n\\n        req = self.make_request('GET', '/')\\n        info1 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info1)\\n        self.assertIs(route, info1.route)\\n\\n        req = self.make_request('POST', '/')\\n        info2 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info2)\\n\\n        self.assertIs(info1.route, info2.route)\\n\\n    def test_match_second_result_in_table(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/h1', handler1)\\n        self.router.add_route('POST', '/h2', handler2)\\n        req = self.make_request('POST', '/h2')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler2, info.handler)\\n\\n    def test_raise_method_not_allowed(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/', handler1)\\n        self.router.add_route('POST', '/', handler2)\\n        req = self.make_request('PUT', '/')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPMethodNotAllowed) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual('PUT', exc.method)\\n        self.assertEqual(405, exc.status)\\n        self.assertEqual({'POST', 'GET'}, exc.allowed_methods)\\n\\n    def test_raise_method_not_found(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/a', handler)\\n        req = self.make_request('GET', '/b')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPNotFound) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual(404, exc.status)\\n\\n    def test_double_add_url_with_the_same_name(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/get', handler1, name='name')\\n\\n        regexp = (\\\"Duplicate 'name', already handled by\\\")\\n        with self.assertRaisesRegex(ValueError, regexp):\\n            self.router.add_route('GET', '/get_other', handler2, name='name')\\n\\n    def test_route_plain(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get', handler, name='name')\\n        route2 = self.router['name']\\n        url = route2.url()\\n        self.assertEqual('/get', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_unknown_route_name(self):\\n        with self.assertRaises(KeyError):\\n            self.router['unknown']\\n\\n    def test_route_dynamic(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{name}', handler,\\n                                      name='name')\\n\\n        route2 = self.router['name']\\n        url = route2.url(parts={'name': 'John'})\\n        self.assertEqual('/get/John', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_with_qs(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get', handler, name='name')\\n\\n        url = self.router['name'].url(query=[('a', 'b'), ('c', 1)])\\n        self.assertEqual('/get?a=b&c=1', url)\\n\\n    def test_add_static(self):\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__),\\n                                       name='static')\\n        route2 = self.router['static']\\n        url = route2.url(filename='/dir/a.txt')\\n        self.assertEqual('/st/dir/a.txt', url)\\n        self.assertIs(route, route2)\\n\\n    def test_plain_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_static_not_match(self):\\n        self.router.add_static('/pre', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_with_trailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}/', handler, name='name')\\n        route = self.router['name']\\n        self.assertEqual({'name': 'John'}, route.match('/get/John/'))\\n\\n    def test_len(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual(2, len(self.router))\\n\\n    def test_iter(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual({'name1', 'name2'}, set(iter(self.router)))\\n\\n    def test_contains(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertIn('name1', self.router)\\n        self.assertNotIn('name3', self.router)\\n\\n    def test_plain_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<PlainRoute 'name' \\\\[GET\\\\] /get/path\\\")\\n\\n    def test_dynamic_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{path}', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<DynamicRoute 'name' \\\\[GET\\\\] /get/{path}\\\")\\n\\n    def test_static_repr(self):\\n        self.router.add_static('/get', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<StaticRoute 'name' \\\\[GET\\\\] /get/\\\")\\n\\n    def test_static_adds_slash(self):\\n        route = self.router.add_static('/prefix',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_static_dont_add_trailing_slash(self):\\n        route = self.router.add_static('/prefix/',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_add_route_with_re(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/1234')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{name}.html', handler)\\n        req = self.make_request('GET', '/handler/test.html')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertEqual({'name': 'test'}, info)\\n\\n    def test_add_route_with_re_and_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:[^/]+/?}', handler)\\n        req = self.make_request('GET', '/handler/1234/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{to:.+}', handler)\\n        req = self.make_request('GET', '/handler/1234/5/6/7')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/5/6/7'}, info)\\n\\n    def test_add_route_with_re_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/tail')\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n        with self.assertRaises(HTTPNotFound):\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n    def test_add_route_with_re_including_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:.+}/tail', handler)\\n        req = self.make_request('GET', '/handler/re/with/slashes/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 're/with/slashes'}, info)\\n\\n    def test_add_route_with_invalid_re(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError) as ctx:\\n            self.router.add_route('GET', r'/handler/{to:+++}', handler)\\n        s = str(ctx.exception)\\n        self.assertTrue(s.startswith(\\n            \\\"Bad pattern '\\\\/handler\\\\/(?P<to>+++)': nothing to repeat\\\"), s)\\n        self.assertIsNone(ctx.exception.__cause__)\\n\\n    def test_route_dynamic_with_regex_spec(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123', url)\\n\\n    def test_route_dynamic_with_regex_spec_and_trailing_slash(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}/', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123/', url)\\n\\n    def test_route_dynamic_with_regex(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', r'/{one}/{two:.+}', handler)\\n\\n        url = route.url(parts={'one': 1, 'two': 2})\\n        self.assertEqual('/1/2', url)\\n\\n    def test_regular_match_info(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/get/{name}', handler)\\n\\n            req = self.make_request('GET', '/get/john')\\n            match_info = yield from self.router.resolve(req)\\n            self.maxDiff = None\\n            self.assertRegex(repr(match_info),\\n                             \\\"<MatchInfo {'name': 'john'}: <DynamicRoute.+>>\\\")\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_found_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            req = self.make_request('POST', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: not found>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_allowed_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/path/to', handler)\\n\\n            handler2 = self.make_handler()\\n            self.router.add_route('POST', '/path/to', handler2)\\n\\n            req = self.make_request('PUT', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: method PUT is not allowed \\\"\\n                             \\\"(allowed methods: GET, POST>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_default_expect_handler(self):\\n        route = self.router.add_route('GET', '/', self.make_handler())\\n        self.assertIs(route._expect_handler, _defaultExpectHandler)\\n\\n    def test_custom_expect_handler_plain(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, PlainRoute)\\n\\n    def test_custom_expect_handler_dynamic(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/get/{name}', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, DynamicRoute)\\n\\n    def test_expect_handler_non_coroutine(self):\\n\\n        def handler(request):\\n            pass\\n\\n        self.assertRaises(\\n            AssertionError, self.router.add_route,\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n\\n    def test_dynamic_match_non_ascii(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{var}', handler)\\n            req = self.make_request(\\n                'GET',\\n                '/%D1%80%D1%83%D1%81%20%D1%82%D0%B5%D0%BA%D1%81%D1%82')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'var': '\u0440\u0443\u0441 \u0442\u0435\u043a\u0441\u0442'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_with_static_part(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.html', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_two_part2(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.{ext}', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file', 'ext': 'html'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_unquoted_path(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{path}/{subpath}', handler)\\n            resource_id = 'my%2Fpath%7Cwith%21some%25strange%24characters'\\n            req = self.make_request('GET', '/path/{0}'.format(resource_id))\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(match_info, {\\n                'path': 'path',\\n                'subpath': unquote(resource_id)\\n            })\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_add_route_not_started_with_slash(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('GET', 'invalid_path', handler)\\n\\n    def test_add_route_invalid_method(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('INVALID_METHOD', '/path', handler)\\n\\n    def test_static_handle_eof(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.return_value = 0\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIsNone(fut.result())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_again(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.side_effect = BlockingIOError()\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertFalse(fut.done())\\n            loop.add_writer.assert_called_with(out_fd, route._sendfile_cb,\\n                                               fut, out_fd, in_fd, 0, 100,\\n                                               loop, True)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_exception(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            exc = OSError()\\n            m_os.sendfile.side_effect = exc\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIs(exc, fut.exception())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def fill_routes(self):\\n        route1 = self.router.add_route('GET', '/plain', self.make_handler())\\n        route2 = self.router.add_route('GET', '/variable/{name}',\\n                                       self.make_handler())\\n        route3 = self.router.add_static('/static',\\n                                        os.path.dirname(aiohttp.__file__))\\n        return route1, route2, route3\\n\\n    def test_routes_view_len(self):\\n        self.fill_routes()\\n        self.assertEqual(3, len(self.router.routes()))\\n\\n    def test_routes_view_iter(self):\\n        routes = self.fill_routes()\\n        self.assertEqual(list(routes), list(self.router.routes()))\\n\\n    def test_routes_view_contains(self):\\n        routes = self.fill_routes()\\n        for route in routes:\\n            self.assertIn(route, self.router.routes())\\n\\n    def test_routes_abc(self):\\n        self.assertIsInstance(self.router.routes(), Sized)\\n        self.assertIsInstance(self.router.routes(), Iterable)\\n        self.assertIsInstance(self.router.routes(), Container)\",\n                            \"ast_type_str\": \"ClassDef\",\n                            \"start_lineno\": 19,\n                            \"end_lineno\": 644,\n                            \"parent\": null\n                        }\n                    ],\n                    \"added_entities\": [],\n                    \"deleted_entities\": []\n                }\n            ]\n        }\n    ],\n    \"old_commit_hash\": \"f0d74880deec8fcd982bce639c93c5e130d41198^\",\n    \"new_commit_hash\": \"f0d74880deec8fcd982bce639c93c5e130d41198\",\n    \"commit_message\": \"Merge branch '0.18'\\n\\nConflicts:\\n\\tCHANGES.txt\\n\\taiohttp/__init__.py\",\n    \"commit_date\": \"2015-10-20T19:38:13+03:00\",\n    \"metadata\": {}\n}", "execution_result_content": "{\n    \"repo_name\": \"aiohttp\",\n    \"new_commit_hash\": \"f0d74880deec8fcd982bce639c93c5e130d41198\",\n    \"test_file_codes\": [\n        \"import asyncio\\nimport os\\nimport unittest\\nfrom collections.abc import Sized, Container, Iterable\\nfrom unittest import mock\\nfrom urllib.parse import unquote\\nimport aiohttp.web\\nfrom aiohttp import hdrs\\nfrom aiohttp.web import (UrlDispatcher, Request, Response,\\n                         HTTPMethodNotAllowed, HTTPNotFound)\\nfrom aiohttp.multidict import CIMultiDict\\nfrom aiohttp.protocol import HttpVersion, RawRequestMessage\\nfrom aiohttp.web_urldispatcher import (_defaultExpectHandler,\\n                                       DynamicRoute,\\n                                       PlainRoute,\\n                                       SystemRoute)\\n\\n\\nclass TestUrlDispatcher(unittest.TestCase):\\n\\n    def setUp(self):\\n        self.loop = asyncio.new_event_loop()\\n        asyncio.set_event_loop(None)\\n        self.router = UrlDispatcher()\\n\\n    def tearDown(self):\\n        self.loop.close()\\n\\n    def make_request(self, method, path):\\n        self.app = mock.Mock()\\n        message = RawRequestMessage(method, path, HttpVersion(1, 1),\\n                                    CIMultiDict(), False, False)\\n        self.payload = mock.Mock()\\n        self.transport = mock.Mock()\\n        self.reader = mock.Mock()\\n        self.writer = mock.Mock()\\n        req = Request(self.app, message, self.payload,\\n                      self.transport, self.reader, self.writer)\\n        return req\\n\\n    def make_handler(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            return Response(request)  # pragma: no cover\\n\\n        return handler\\n\\n    def test_system_route(self):\\n        route = SystemRoute(201, 'test')\\n        self.assertIsNone(route.match('any'))\\n        with self.assertRaises(RuntimeError):\\n            route.url()\\n        self.assertEqual(\\\"<SystemRoute 201: test>\\\", repr(route))\\n        self.assertEqual(201, route.status)\\n        self.assertEqual('test', route.reason)\\n\\n    def test_register_route(self):\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(route, info.route)\\n        self.assertIs(handler, info.handler)\\n        self.assertEqual(info.route.name, 'test')\\n\\n    def test_register_route_checks(self):\\n        self.assertRaises(\\n            AssertionError, self.router.register_route, object())\\n\\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, '1bad name', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, 'return', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n\\n        route = PlainRoute('GET', handler, 'test.test:test',\\n                           '/handler/to/path')\\n        self.router.register_route(route)\\n\\n    def test_add_route_root(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/', handler)\\n        req = self.make_request('GET', '/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_route_simple(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler)\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual(0, len(info))\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_matchdict(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/{to}', handler)\\n        req = self.make_request('GET', '/handler/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 'tail'}, info)\\n        self.assertIs(handler, info.handler)\\n        self.assertIsNone(info.route.name)\\n\\n    def test_add_with_name(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path', handler,\\n                              name='name')\\n        req = self.make_request('GET', '/handler/to/path')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual('name', info.route.name)\\n\\n    def test_add_with_tailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/handler/to/path/', handler)\\n        req = self.make_request('GET', '/handler/to/path/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_add_invalid_path(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('GET', '/{/', handler)\\n\\n    def test_add_url_invalid1(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id', handler)\\n\\n    def test_add_url_invalid2(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}}', handler)\\n\\n    def test_add_url_invalid3(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id{}', handler)\\n\\n    def test_add_url_invalid4(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError):\\n            self.router.add_route('post', '/post/{id\\\"}', handler)\\n\\n    def test_add_url_escaping(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/+$', handler)\\n\\n        req = self.make_request('GET', '/+$')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertIs(handler, info.handler)\\n\\n    def test_any_method(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route(hdrs.METH_ANY, '/', handler)\\n\\n        req = self.make_request('GET', '/')\\n        info1 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info1)\\n        self.assertIs(route, info1.route)\\n\\n        req = self.make_request('POST', '/')\\n        info2 = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info2)\\n\\n        self.assertIs(info1.route, info2.route)\\n\\n    def test_match_second_result_in_table(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/h1', handler1)\\n        self.router.add_route('POST', '/h2', handler2)\\n        req = self.make_request('POST', '/h2')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({}, info)\\n        self.assertIs(handler2, info.handler)\\n\\n    def test_raise_method_not_allowed(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/', handler1)\\n        self.router.add_route('POST', '/', handler2)\\n        req = self.make_request('PUT', '/')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPMethodNotAllowed) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual('PUT', exc.method)\\n        self.assertEqual(405, exc.status)\\n        self.assertEqual({'POST', 'GET'}, exc.allowed_methods)\\n\\n    def test_raise_method_not_found(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/a', handler)\\n        req = self.make_request('GET', '/b')\\n\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n\\n        with self.assertRaises(HTTPNotFound) as ctx:\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n        exc = ctx.exception\\n        self.assertEqual(404, exc.status)\\n\\n    def test_double_add_url_with_the_same_name(self):\\n        handler1 = self.make_handler()\\n        handler2 = self.make_handler()\\n        self.router.add_route('GET', '/get', handler1, name='name')\\n\\n        regexp = (\\\"Duplicate 'name', already handled by\\\")\\n        with self.assertRaisesRegex(ValueError, regexp):\\n            self.router.add_route('GET', '/get_other', handler2, name='name')\\n\\n    def test_route_plain(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get', handler, name='name')\\n        route2 = self.router['name']\\n        url = route2.url()\\n        self.assertEqual('/get', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_unknown_route_name(self):\\n        with self.assertRaises(KeyError):\\n            self.router['unknown']\\n\\n    def test_route_dynamic(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{name}', handler,\\n                                      name='name')\\n\\n        route2 = self.router['name']\\n        url = route2.url(parts={'name': 'John'})\\n        self.assertEqual('/get/John', url)\\n        self.assertIs(route, route2)\\n\\n    def test_route_with_qs(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get', handler, name='name')\\n\\n        url = self.router['name'].url(query=[('a', 'b'), ('c', 1)])\\n        self.assertEqual('/get?a=b&c=1', url)\\n\\n    def test_add_static(self):\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__),\\n                                       name='static')\\n        route2 = self.router['static']\\n        url = route2.url(filename='/dir/a.txt')\\n        self.assertEqual('/st/dir/a.txt', url)\\n        self.assertIs(route, route2)\\n\\n    def test_plain_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}', handler, name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_static_not_match(self):\\n        self.router.add_static('/pre', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        route = self.router['name']\\n        self.assertIsNone(route.match('/another/path'))\\n\\n    def test_dynamic_with_trailing_slash(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{name}/', handler, name='name')\\n        route = self.router['name']\\n        self.assertEqual({'name': 'John'}, route.match('/get/John/'))\\n\\n    def test_len(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual(2, len(self.router))\\n\\n    def test_iter(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertEqual({'name1', 'name2'}, set(iter(self.router)))\\n\\n    def test_contains(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get1', handler, name='name1')\\n        self.router.add_route('GET', '/get2', handler, name='name2')\\n        self.assertIn('name1', self.router)\\n        self.assertNotIn('name3', self.router)\\n\\n    def test_plain_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/path', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<PlainRoute 'name' \\\\[GET\\\\] /get/path\\\")\\n\\n    def test_dynamic_repr(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', '/get/{path}', handler, name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<DynamicRoute 'name' \\\\[GET\\\\] /get/{path}\\\")\\n\\n    def test_static_repr(self):\\n        self.router.add_static('/get', os.path.dirname(aiohttp.__file__),\\n                               name='name')\\n        self.assertRegex(repr(self.router['name']),\\n                         r\\\"<StaticRoute 'name' \\\\[GET\\\\] /get/\\\")\\n\\n    def test_static_adds_slash(self):\\n        route = self.router.add_static('/prefix',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_static_dont_add_trailing_slash(self):\\n        route = self.router.add_static('/prefix/',\\n                                       os.path.dirname(aiohttp.__file__))\\n        self.assertEqual('/prefix/', route._prefix)\\n\\n    def test_add_route_with_re(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/1234')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{name}.html', handler)\\n        req = self.make_request('GET', '/handler/test.html')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertEqual({'name': 'test'}, info)\\n\\n    def test_add_route_with_re_and_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:[^/]+/?}', handler)\\n        req = self.make_request('GET', '/handler/1234/')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/'}, info)\\n\\n        self.router.add_route('GET', r'/handler/{to:.+}', handler)\\n        req = self.make_request('GET', '/handler/1234/5/6/7')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': '1234/5/6/7'}, info)\\n\\n    def test_add_route_with_re_not_match(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:\\\\d+}', handler)\\n\\n        req = self.make_request('GET', '/handler/tail')\\n        match_info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsInstance(match_info.route, SystemRoute)\\n        self.assertEqual({}, match_info)\\n        with self.assertRaises(HTTPNotFound):\\n            self.loop.run_until_complete(match_info.handler(req))\\n\\n    def test_add_route_with_re_including_slashes(self):\\n        handler = self.make_handler()\\n        self.router.add_route('GET', r'/handler/{to:.+}/tail', handler)\\n        req = self.make_request('GET', '/handler/re/with/slashes/tail')\\n        info = self.loop.run_until_complete(self.router.resolve(req))\\n        self.assertIsNotNone(info)\\n        self.assertEqual({'to': 're/with/slashes'}, info)\\n\\n    def test_add_route_with_invalid_re(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError) as ctx:\\n            self.router.add_route('GET', r'/handler/{to:+++}', handler)\\n        s = str(ctx.exception)\\n        self.assertTrue(s.startswith(\\n            \\\"Bad pattern '\\\\/handler\\\\/(?P<to>+++)': nothing to repeat\\\"), s)\\n        self.assertIsNone(ctx.exception.__cause__)\\n\\n    def test_route_dynamic_with_regex_spec(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123', url)\\n\\n    def test_route_dynamic_with_regex_spec_and_trailing_slash(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', '/get/{num:^\\\\d+}/', handler,\\n                                      name='name')\\n\\n        url = route.url(parts={'num': '123'})\\n        self.assertEqual('/get/123/', url)\\n\\n    def test_route_dynamic_with_regex(self):\\n        handler = self.make_handler()\\n        route = self.router.add_route('GET', r'/{one}/{two:.+}', handler)\\n\\n        url = route.url(parts={'one': 1, 'two': 2})\\n        self.assertEqual('/1/2', url)\\n\\n    def test_regular_match_info(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/get/{name}', handler)\\n\\n            req = self.make_request('GET', '/get/john')\\n            match_info = yield from self.router.resolve(req)\\n            self.maxDiff = None\\n            self.assertRegex(repr(match_info),\\n                             \\\"<MatchInfo {'name': 'john'}: <DynamicRoute.+>>\\\")\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_found_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            req = self.make_request('POST', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: not found>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_not_allowed_repr(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/path/to', handler)\\n\\n            handler2 = self.make_handler()\\n            self.router.add_route('POST', '/path/to', handler2)\\n\\n            req = self.make_request('PUT', '/path/to')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(\\\"<MatchInfo: method PUT is not allowed \\\"\\n                             \\\"(allowed methods: GET, POST>\\\", repr(match_info))\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_default_expect_handler(self):\\n        route = self.router.add_route('GET', '/', self.make_handler())\\n        self.assertIs(route._expect_handler, _defaultExpectHandler)\\n\\n    def test_custom_expect_handler_plain(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, PlainRoute)\\n\\n    def test_custom_expect_handler_dynamic(self):\\n\\n        @asyncio.coroutine\\n        def handler(request):\\n            pass\\n\\n        route = self.router.add_route(\\n            'GET', '/get/{name}', self.make_handler(), expect_handler=handler)\\n        self.assertIs(route._expect_handler, handler)\\n        self.assertIsInstance(route, DynamicRoute)\\n\\n    def test_expect_handler_non_coroutine(self):\\n\\n        def handler(request):\\n            pass\\n\\n        self.assertRaises(\\n            AssertionError, self.router.add_route,\\n            'GET', '/', self.make_handler(), expect_handler=handler)\\n\\n    def test_dynamic_match_non_ascii(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{var}', handler)\\n            req = self.make_request(\\n                'GET',\\n                '/%D1%80%D1%83%D1%81%20%D1%82%D0%B5%D0%BA%D1%81%D1%82')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'var': '\u0440\u0443\u0441 \u0442\u0435\u043a\u0441\u0442'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_with_static_part(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.html', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_two_part2(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{name}.{ext}', handler)\\n            req = self.make_request('GET', '/file.html')\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual({'name': 'file', 'ext': 'html'}, match_info)\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_dynamic_match_unquoted_path(self):\\n\\n        @asyncio.coroutine\\n        def go():\\n            handler = self.make_handler()\\n            self.router.add_route('GET', '/{path}/{subpath}', handler)\\n            resource_id = 'my%2Fpath%7Cwith%21some%25strange%24characters'\\n            req = self.make_request('GET', '/path/{0}'.format(resource_id))\\n            match_info = yield from self.router.resolve(req)\\n            self.assertEqual(match_info, {\\n                'path': 'path',\\n                'subpath': unquote(resource_id)\\n            })\\n\\n        self.loop.run_until_complete(go())\\n\\n    def test_add_route_not_started_with_slash(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('GET', 'invalid_path', handler)\\n\\n    def test_add_route_invalid_method(self):\\n        with self.assertRaises(ValueError):\\n            handler = self.make_handler()\\n            self.router.add_route('INVALID_METHOD', '/path', handler)\\n\\n    def test_static_handle_eof(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.return_value = 0\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIsNone(fut.result())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_again(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            m_os.sendfile.side_effect = BlockingIOError()\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertFalse(fut.done())\\n            loop.add_writer.assert_called_with(out_fd, route._sendfile_cb,\\n                                               fut, out_fd, in_fd, 0, 100,\\n                                               loop, True)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def test_static_handle_exception(self):\\n        loop = mock.Mock()\\n        route = self.router.add_static('/st',\\n                                       os.path.dirname(aiohttp.__file__))\\n        with mock.patch('aiohttp.web_urldispatcher.os') as m_os:\\n            out_fd = 30\\n            in_fd = 31\\n            fut = asyncio.Future(loop=self.loop)\\n            exc = OSError()\\n            m_os.sendfile.side_effect = exc\\n            route._sendfile_cb(fut, out_fd, in_fd, 0, 100, loop, False)\\n            m_os.sendfile.assert_called_with(out_fd, in_fd, 0, 100)\\n            self.assertTrue(fut.done())\\n            self.assertIs(exc, fut.exception())\\n            self.assertFalse(loop.add_writer.called)\\n            self.assertFalse(loop.remove_writer.called)\\n\\n    def fill_routes(self):\\n        route1 = self.router.add_route('GET', '/plain', self.make_handler())\\n        route2 = self.router.add_route('GET', '/variable/{name}',\\n                                       self.make_handler())\\n        route3 = self.router.add_static('/static',\\n                                        os.path.dirname(aiohttp.__file__))\\n        return route1, route2, route3\\n\\n    def test_routes_view_len(self):\\n        self.fill_routes()\\n        self.assertEqual(3, len(self.router.routes()))\\n\\n    def test_routes_view_iter(self):\\n        routes = self.fill_routes()\\n        self.assertEqual(list(routes), list(self.router.routes()))\\n\\n    def test_routes_view_contains(self):\\n        routes = self.fill_routes()\\n        for route in routes:\\n            self.assertIn(route, self.router.routes())\\n\\n    def test_routes_abc(self):\\n        self.assertIsInstance(self.router.routes(), Sized)\\n        self.assertIsInstance(self.router.routes(), Iterable)\\n        self.assertIsInstance(self.router.routes(), Container)\\n\",\n        \"import asyncio\\nimport aiohttp\\nimport collections\\nimport gc\\nimport logging\\nimport pytest\\nimport re\\nimport socket\\nimport sys\\nimport warnings\\n\\nfrom aiohttp import web\\n\\n\\nclass _AssertWarnsContext:\\n    \\\"\\\"\\\"A context manager used to implement TestCase.assertWarns* methods.\\\"\\\"\\\"\\n\\n    def __init__(self, expected, expected_regex=None):\\n        self.expected = expected\\n        if expected_regex is not None:\\n            expected_regex = re.compile(expected_regex)\\n        self.expected_regex = expected_regex\\n        self.obj_name = None\\n\\n    def __enter__(self):\\n        # The __warningregistry__'s need to be in a pristine state for tests\\n        # to work properly.\\n        for v in sys.modules.values():\\n            if getattr(v, '__warningregistry__', None):\\n                v.__warningregistry__ = {}\\n        self.warnings_manager = warnings.catch_warnings(record=True)\\n        self.warnings = self.warnings_manager.__enter__()\\n        warnings.simplefilter(\\\"always\\\", self.expected)\\n        return self\\n\\n    def __exit__(self, exc_type, exc_value, tb):\\n        self.warnings_manager.__exit__(exc_type, exc_value, tb)\\n        if exc_type is not None:\\n            # let unexpected exceptions pass through\\n            return\\n        try:\\n            exc_name = self.expected.__name__\\n        except AttributeError:\\n            exc_name = str(self.expected)\\n        first_matching = None\\n        for m in self.warnings:\\n            w = m.message\\n            if not isinstance(w, self.expected):\\n                continue\\n            if first_matching is None:\\n                first_matching = w\\n            if (self.expected_regex is not None and\\n                    not self.expected_regex.search(str(w))):\\n                continue\\n            # store warning for later retrieval\\n            self.warning = w\\n            self.filename = m.filename\\n            self.lineno = m.lineno\\n            return\\n        # Now we simply try to choose a helpful failure message\\n        if first_matching is not None:\\n            __tracebackhide__ = True\\n            assert 0, '\\\"{}\\\" does not match \\\"{}\\\"'.format(\\n                self.expected_regex.pattern, str(first_matching))\\n        if self.obj_name:\\n            __tracebackhide__ = True\\n            assert 0, \\\"{} not triggered by {}\\\".format(exc_name,\\n                                                      self.obj_name)\\n        else:\\n            __tracebackhide__ = True\\n            assert 0, \\\"{} not triggered\\\".format(exc_name)\\n\\n\\n_LoggingWatcher = collections.namedtuple(\\\"_LoggingWatcher\\\",\\n                                         [\\\"records\\\", \\\"output\\\"])\\n\\n\\nclass _CapturingHandler(logging.Handler):\\n    \\\"\\\"\\\"\\n    A logging handler capturing all (raw and formatted) logging output.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self):\\n        logging.Handler.__init__(self)\\n        self.watcher = _LoggingWatcher([], [])\\n\\n    def flush(self):\\n        pass\\n\\n    def emit(self, record):\\n        self.watcher.records.append(record)\\n        msg = self.format(record)\\n        self.watcher.output.append(msg)\\n\\n\\nclass _AssertLogsContext:\\n    \\\"\\\"\\\"A context manager used to implement TestCase.assertLogs().\\\"\\\"\\\"\\n\\n    LOGGING_FORMAT = \\\"%(levelname)s:%(name)s:%(message)s\\\"\\n\\n    def __init__(self, logger_name=None, level=None):\\n        self.logger_name = logger_name\\n        if level:\\n            self.level = logging._nameToLevel.get(level, level)\\n        else:\\n            self.level = logging.INFO\\n        self.msg = None\\n\\n    def __enter__(self):\\n        if isinstance(self.logger_name, logging.Logger):\\n            logger = self.logger = self.logger_name\\n        else:\\n            logger = self.logger = logging.getLogger(self.logger_name)\\n        formatter = logging.Formatter(self.LOGGING_FORMAT)\\n        handler = _CapturingHandler()\\n        handler.setFormatter(formatter)\\n        self.watcher = handler.watcher\\n        self.old_handlers = logger.handlers[:]\\n        self.old_level = logger.level\\n        self.old_propagate = logger.propagate\\n        logger.handlers = [handler]\\n        logger.setLevel(self.level)\\n        logger.propagate = False\\n        return handler.watcher\\n\\n    def __exit__(self, exc_type, exc_value, tb):\\n        self.logger.handlers = self.old_handlers\\n        self.logger.propagate = self.old_propagate\\n        self.logger.setLevel(self.old_level)\\n        if exc_type is not None:\\n            # let unexpected exceptions pass through\\n            return False\\n        if len(self.watcher.records) == 0:\\n            __tracebackhide__ = True\\n            assert 0, (\\\"no logs of level {} or higher triggered on {}\\\"\\n                       .format(logging.getLevelName(self.level),\\n                               self.logger.name))\\n\\n\\n@pytest.yield_fixture\\ndef warning():\\n    yield _AssertWarnsContext\\n\\n\\n@pytest.yield_fixture\\ndef log():\\n    yield _AssertLogsContext\\n\\n\\n@pytest.fixture\\ndef unused_port():\\n    def f():\\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\\n            s.bind(('127.0.0.1', 0))\\n            return s.getsockname()[1]\\n    return f\\n\\n\\n@pytest.yield_fixture\\ndef loop(request):\\n    loop = asyncio.new_event_loop()\\n    asyncio.set_event_loop(None)\\n\\n    yield loop\\n\\n    loop.stop()\\n    loop.run_forever()\\n    loop.close()\\n    gc.collect()\\n    asyncio.set_event_loop(None)\\n\\n\\n@pytest.yield_fixture\\ndef create_server(loop, unused_port):\\n    app = handler = srv = None\\n\\n    @asyncio.coroutine\\n    def create(*, debug=False, ssl_ctx=None):\\n        nonlocal app, handler, srv\\n        app = web.Application(loop=loop)\\n        port = unused_port()\\n        handler = app.make_handler(debug=debug, keep_alive_on=False)\\n        srv = yield from loop.create_server(handler, '127.0.0.1', port,\\n                                            ssl=ssl_ctx)\\n        proto = \\\"https\\\" if ssl_ctx else \\\"http\\\"\\n        url = \\\"{}://127.0.0.1:{}\\\".format(proto, port)\\n        return app, url\\n\\n    yield create\\n\\n    @asyncio.coroutine\\n    def finish():\\n        yield from handler.finish_connections()\\n        yield from app.finish()\\n        srv.close()\\n        yield from srv.wait_closed()\\n\\n    loop.run_until_complete(finish())\\n\\n\\nclass Client:\\n    def __init__(self, session, url):\\n        self._session = session\\n        if not url.endswith('/'):\\n            url += '/'\\n        self._url = url\\n\\n    def close(self):\\n        self._session.close()\\n\\n    def get(self, path, **kwargs):\\n        while path.startswith('/'):\\n            path = path[1:]\\n        url = self._url + path\\n        return self._session.get(url, **kwargs)\\n\\n    def post(self, path, **kwargs):\\n        while path.startswith('/'):\\n            path = path[1:]\\n        url = self._url + path\\n        return self._session.post(url, **kwargs)\\n\\n\\n@pytest.yield_fixture\\ndef create_app_and_client(create_server, loop):\\n    client = None\\n\\n    @asyncio.coroutine\\n    def maker(*, server_params=None, client_params=None):\\n        nonlocal client\\n        if server_params is None:\\n            server_params = {}\\n        server_params.setdefault('debug', False)\\n        server_params.setdefault('ssl_ctx', None)\\n        app, url = yield from create_server(**server_params)\\n        if client_params is None:\\n            client_params = {}\\n        client = Client(aiohttp.ClientSession(loop=loop, **client_params), url)\\n        return app, client\\n\\n    yield maker\\n    client.close()\\n\\n\\n@pytest.mark.tryfirst\\ndef pytest_pycollect_makeitem(collector, name, obj):\\n    if collector.funcnamefilter(name):\\n        if not callable(obj):\\n            return\\n        item = pytest.Function(name, parent=collector)\\n        if 'run_loop' in item.keywords:\\n            return list(collector._genfunctions(name, obj))\\n\\n\\n@pytest.mark.tryfirst\\ndef pytest_pyfunc_call(pyfuncitem):\\n    \\\"\\\"\\\"\\n    Run asyncio marked test functions in an event loop instead of a normal\\n    function call.\\n    \\\"\\\"\\\"\\n    if 'run_loop' in pyfuncitem.keywords:\\n        funcargs = pyfuncitem.funcargs\\n        loop = funcargs['loop']\\n        testargs = {arg: funcargs[arg]\\n                    for arg in pyfuncitem._fixtureinfo.argnames}\\n        loop.run_until_complete(pyfuncitem.obj(**testargs))\\n        return True\\n\\n\\ndef pytest_runtest_setup(item):\\n    if 'run_loop' in item.keywords and 'loop' not in item.fixturenames:\\n        # inject an event loop fixture for all async tests\\n        item.fixturenames.append('loop')\\n\\n\\ndef pytest_ignore_collect(path, config):\\n    if 'test_py35' in str(path):\\n        if sys.version_info < (3, 5, 0):\\n            return True\\n\"\n    ],\n    \"test_file_names\": [\n        \"test_1.py\",\n        \"conftest.py\"\n    ],\n    \"setup_res_code\": 0,\n    \"setup_res_stdout\": \"uv pip install -U -r requirements-dev.txt\\nTransforming aiohttp/worker.py\\nTransforming aiohttp/client_reqrep.py\\nTransforming aiohttp/server.py\\n\",\n    \"setup_res_stderr\": \"Using CPython 3.9.21\\nCreating virtual environment at: .venv\\nActivate with: source .venv/bin/activate\\nResolved 68 packages in 693ms\\n  \u00d7 Failed to build `aiohttp @ file:///home/gcpuser/buckets/local_repoeval_bucket/repos/aiohttp_f0d74880deec8fcd982bce639c93c5e130d41198`\\n  \u251c\u2500\u25b6 The build backend returned an error\\n  \u2570\u2500\u25b6 Call to `setuptools.build_meta:__legacy__.build_editable` failed (exit status: 1)\\n\\n      [stdout]\\n      running editable_wheel\\n      creating /home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp.egg-info\\n      writing /home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp.egg-info/PKG-INFO\\n      writing dependency_links to /home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp.egg-info/dependency_links.txt\\n      writing requirements to /home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp.egg-info/requires.txt\\n      writing top-level names to /home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp.egg-info/top_level.txt\\n      writing manifest file '/home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp.egg-info/SOURCES.txt'\\n      reading manifest file '/home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp.egg-info/SOURCES.txt'\\n      reading manifest template 'MANIFEST.in'\\n      adding license file 'LICENSE.txt'\\n      writing manifest file '/home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp.egg-info/SOURCES.txt'\\n      creating '/home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp-0.19.0a0.dist-info'\\n      creating /home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp-0.19.0a0.dist-info/WHEEL\\n      running build_py\\n      running build_ext\\n      building 'aiohttp._multidict' extension\\n      creating /tmp/tmp6g_14otu.build-temp/aiohttp\\n      cc -pthread -Wno-unused-result -Wsign-compare -Wunreachable-code -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -fPIC\\n      -I/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/include -I/home/gcpuser/.local/share/uv/python/cpython-3.9.21-linux-x86_64-gnu/include/python3.9 -c\\n      aiohttp/_multidict.c -o /tmp/tmp6g_14otu.build-temp/aiohttp/_multidict.o\\n      ************************************************************\\n      Cannot compile C accelerator module, use pure python version\\n      ************************************************************\\n      running editable_wheel\\n\\n      [stderr]\\n      <string>:9: SetuptoolsDeprecationWarning: The test command is disabled and references to it are deprecated.\\n      !!\\n\\n              ********************************************************************************\\n              Please remove any references to `setuptools.command.test` in all supported versions of the affected package.\\n\\n              This deprecation is overdue, please update your project and remove deprecated\\n              calls to avoid build errors in the future.\\n              ********************************************************************************\\n\\n      !!\\n      /home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/dist.py:261: UserWarning: Unknown distribution option:\\n      'tests_require'\\n        warnings.warn(msg)\\n      warning: no previously-included files matching '*.pyc' found anywhere in distribution\\n      warning: no previously-included files found matching 'aiohttp/_multidict.html'\\n      warning: no previously-included files found matching 'aiohttp/_multidict.*.so'\\n      warning: no previously-included files found matching 'aiohttp/_multidict.pyd'\\n      warning: no previously-included files found matching 'aiohttp/_multidict.*.pyd'\\n      warning: no previously-included files found matching 'aiohttp/_websocket.html'\\n      warning: no previously-included files found matching 'aiohttp/_websocket.*.so'\\n      warning: no previously-included files found matching 'aiohttp/_websocket.pyd'\\n      warning: no previously-included files found matching 'aiohttp/_websocket.*.pyd'\\n      no previously-included directories found matching 'docs/_build'\\n      cc1: fatal error: aiohttp/_multidict.c: No such file or directory\\n      compilation terminated.\\n      Traceback (most recent call last):\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/spawn.py\\\", line 70, in spawn\\n          subprocess.check_call(cmd, env=_inject_macos_ver(env))\\n        File \\\"/home/gcpuser/.local/share/uv/python/cpython-3.9.21-linux-x86_64-gnu/lib/python3.9/subprocess.py\\\", line 373, in check_call\\n          raise CalledProcessError(retcode, cmd)\\n      subprocess.CalledProcessError: Command '['/usr/bin/cc', '-pthread', '-Wno-unused-result', '-Wsign-compare', '-Wunreachable-code',\\n      '-DNDEBUG', '-g', '-fwrapv', '-O3', '-Wall', '-fPIC', '-fPIC', '-I/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/include',\\n      '-I/home/gcpuser/.local/share/uv/python/cpython-3.9.21-linux-x86_64-gnu/include/python3.9', '-c', 'aiohttp/_multidict.c', '-o',\\n      '/tmp/tmp6g_14otu.build-temp/aiohttp/_multidict.o']' returned non-zero exit status 1.\\n\\n      The above exception was the direct cause of the following exception:\\n\\n      Traceback (most recent call last):\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/unixccompiler.py\\\", line 200, in _compile\\n          self.spawn(compiler_so + cc_args + [src, '-o', obj] + extra_postargs)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/ccompiler.py\\\", line 1045, in spawn\\n          spawn(cmd, dry_run=self.dry_run, **kwargs)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/spawn.py\\\", line 76, in spawn\\n          raise DistutilsExecError(\\n      distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1\\n\\n      During handling of the above exception, another exception occurred:\\n\\n      Traceback (most recent call last):\\n        File \\\"<string>\\\", line 43, in build_extension\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/command/build_ext.py\\\", line 557, in build_extension\\n          objects = self.compiler.compile(\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/ccompiler.py\\\", line 606, in compile\\n          self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/unixccompiler.py\\\", line 202, in _compile\\n          raise CompileError(msg)\\n      distutils.errors.CompileError: command '/usr/bin/cc' failed with exit code 1\\n\\n      During handling of the above exception, another exception occurred:\\n\\n      Traceback (most recent call last):\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/editable_wheel.py\\\", line 139, in run\\n          self._create_wheel_file(bdist_wheel)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/editable_wheel.py\\\", line 340, in _create_wheel_file\\n          files, mapping = self._run_build_commands(dist_name, unpacked, lib, tmp)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/editable_wheel.py\\\", line 263, in _run_build_commands\\n          self._run_build_subcommands()\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/editable_wheel.py\\\", line 290, in _run_build_subcommands\\n          self.run_command(name)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/cmd.py\\\", line 316, in run_command\\n          self.distribution.run_command(command)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/dist.py\\\", line 995, in run_command\\n          super().run_command(command)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/dist.py\\\", line 973, in run_command\\n          cmd_obj.run()\\n        File \\\"<string>\\\", line 37, in run\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/command/build_ext.py\\\", line 359, in run\\n          self.build_extensions()\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/command/build_ext.py\\\", line 476, in build_extensions\\n          self._build_extensions_serial()\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/command/build_ext.py\\\", line 502, in\\n      _build_extensions_serial\\n          self.build_extension(ext)\\n        File \\\"<string>\\\", line 46, in build_extension\\n      BuildFailed\\n      /home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/dist.py:973: _DebuggingTips: Problem in editable installation.\\n      !!\\n\\n              ********************************************************************************\\n              An error happened while installing `aiohttp` in editable mode.\\n\\n              The following steps are recommended to help debug this problem:\\n\\n              - Try to install the project normally, without using the editable mode.\\n                Does the error still persist?\\n                (If it does, try fixing the problem before attempting the editable mode).\\n              - If you are using binary extensions, make sure you have all OS-level\\n                dependencies installed (e.g. compilers, toolchains, binary libraries, ...).\\n              - Try the latest version of setuptools (maybe the error was already fixed).\\n              - If you (or your project dependencies) are using any setuptools extension\\n                or customization, make sure they support the editable mode.\\n\\n              After following the steps above, if the problem still persists and\\n              you think this is related to how setuptools handles editable installations,\\n              please submit a reproducible example\\n              (see https://stackoverflow.com/help/minimal-reproducible-example) to:\\n\\n                  https://github.com/pypa/setuptools/issues\\n\\n              See https://setuptools.pypa.io/en/latest/userguide/development_mode.html for details.\\n              ********************************************************************************\\n\\n      !!\\n        cmd_obj.run()\\n      Traceback (most recent call last):\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/spawn.py\\\", line 70, in spawn\\n          subprocess.check_call(cmd, env=_inject_macos_ver(env))\\n        File \\\"/home/gcpuser/.local/share/uv/python/cpython-3.9.21-linux-x86_64-gnu/lib/python3.9/subprocess.py\\\", line 373, in check_call\\n          raise CalledProcessError(retcode, cmd)\\n      subprocess.CalledProcessError: Command '['/usr/bin/cc', '-pthread', '-Wno-unused-result', '-Wsign-compare', '-Wunreachable-code',\\n      '-DNDEBUG', '-g', '-fwrapv', '-O3', '-Wall', '-fPIC', '-fPIC', '-I/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/include',\\n      '-I/home/gcpuser/.local/share/uv/python/cpython-3.9.21-linux-x86_64-gnu/include/python3.9', '-c', 'aiohttp/_multidict.c', '-o',\\n      '/tmp/tmp6g_14otu.build-temp/aiohttp/_multidict.o']' returned non-zero exit status 1.\\n\\n      The above exception was the direct cause of the following exception:\\n\\n      Traceback (most recent call last):\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/unixccompiler.py\\\", line 200, in _compile\\n          self.spawn(compiler_so + cc_args + [src, '-o', obj] + extra_postargs)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/ccompiler.py\\\", line 1045, in spawn\\n          spawn(cmd, dry_run=self.dry_run, **kwargs)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/spawn.py\\\", line 76, in spawn\\n          raise DistutilsExecError(\\n      distutils.errors.DistutilsExecError: command '/usr/bin/cc' failed with exit code 1\\n\\n      During handling of the above exception, another exception occurred:\\n\\n      Traceback (most recent call last):\\n        File \\\"<string>\\\", line 43, in build_extension\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/command/build_ext.py\\\", line 557, in build_extension\\n          objects = self.compiler.compile(\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/ccompiler.py\\\", line 606, in compile\\n          self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/unixccompiler.py\\\", line 202, in _compile\\n          raise CompileError(msg)\\n      distutils.errors.CompileError: command '/usr/bin/cc' failed with exit code 1\\n\\n      During handling of the above exception, another exception occurred:\\n\\n      Traceback (most recent call last):\\n        File \\\"<string>\\\", line 107, in <module>\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/__init__.py\\\", line 117, in setup\\n          return distutils.core.setup(**attrs)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/core.py\\\", line 183, in setup\\n          return run_commands(dist)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/core.py\\\", line 199, in run_commands\\n          dist.run_commands()\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/dist.py\\\", line 954, in run_commands\\n          self.run_command(cmd)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/dist.py\\\", line 995, in run_command\\n          super().run_command(command)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/dist.py\\\", line 973, in run_command\\n          cmd_obj.run()\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/editable_wheel.py\\\", line 139, in run\\n          self._create_wheel_file(bdist_wheel)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/editable_wheel.py\\\", line 340, in _create_wheel_file\\n          files, mapping = self._run_build_commands(dist_name, unpacked, lib, tmp)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/editable_wheel.py\\\", line 263, in _run_build_commands\\n          self._run_build_subcommands()\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/editable_wheel.py\\\", line 290, in _run_build_subcommands\\n          self.run_command(name)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/cmd.py\\\", line 316, in run_command\\n          self.distribution.run_command(command)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/dist.py\\\", line 995, in run_command\\n          super().run_command(command)\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/dist.py\\\", line 973, in run_command\\n          cmd_obj.run()\\n        File \\\"<string>\\\", line 37, in run\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/command/build_ext.py\\\", line 359, in run\\n          self.build_extensions()\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/command/build_ext.py\\\", line 476, in build_extensions\\n          self._build_extensions_serial()\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/_distutils/command/build_ext.py\\\", line 502, in\\n      _build_extensions_serial\\n          self.build_extension(ext)\\n        File \\\"<string>\\\", line 46, in build_extension\\n      BuildFailed\\n\\n      During handling of the above exception, another exception occurred:\\n\\n      Traceback (most recent call last):\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/egg_info.py\\\", line 300, in run\\n          os.utime(self.egg_info, None)\\n      FileNotFoundError: [Errno 2] No such file or directory\\n\\n      The above exception was the direct cause of the following exception:\\n\\n      Traceback (most recent call last):\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/editable_wheel.py\\\", line 132, in run\\n          self._ensure_dist_info()\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/editable_wheel.py\\\", line 151, in _ensure_dist_info\\n          dist_info.run()\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/dist_info.py\\\", line 94, in run\\n          self.egg_info.run()\\n        File \\\"/home/gcpuser/.cache/uv/builds-v0/.tmp4lNqUp/lib/python3.9/site-packages/setuptools/command/egg_info.py\\\", line 303, in run\\n          raise distutils.errors.DistutilsFileError(msg) from e\\n      distutils.errors.DistutilsFileError: Cannot update time stamp of directory '/home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp.egg-info'\\n      error: Cannot update time stamp of directory '/home/gcpuser/.cache/uv/builds-v0/.tmpLzTbCK/.tmp-mqiwo8n3/aiohttp.egg-info'\\n\\n      hint: This usually indicates a problem with the package or the build environment.\\nmake: *** [Makefile:4: .install-deps] Error 1\\nResolved 26 packages in 27ms\\nInstalled 26 packages in 16ms\\n + async-generator==1.10\\n + async-timeout==5.0.1\\n + brotlipy==0.7.0\\n + cffi==1.17.1\\n + chardet==5.2.0\\n + coverage==7.6.10\\n + cryptography==44.0.0\\n + cython==3.0.11\\n + exceptiongroup==1.2.2\\n + gunicorn==23.0.0\\n + idna==3.10\\n + iniconfig==2.0.0\\n + multdict==0.0.5\\n + multidict==6.1.0\\n + packaging==24.2\\n + pluggy==1.5.0\\n + propcache==0.2.1\\n + pycparser==2.22\\n + pytest==8.3.4\\n + pytest-asyncio==0.25.1\\n + pytest-cov==6.0.0\\n + pytest-mock==3.14.0\\n + tomli==2.2.1\\n + trustme==1.2.1\\n + typing-extensions==4.12.2\\n + yarl==1.18.3\\n\",\n    \"new_commit_res_code\": 1,\n    \"new_commit_res_stdout\": \"============================= test session starts ==============================\\nplatform linux -- Python 3.9.21, pytest-8.3.4, pluggy-1.5.0\\nrootdir: /home/gcpuser/buckets/local_repoeval_bucket/repos/aiohttp_f0d74880deec8fcd982bce639c93c5e130d41198\\nplugins: mock-3.14.0, asyncio-0.25.1, cov-6.0.0\\nasyncio: mode=strict, asyncio_default_fixture_loop_scope=None\\ncollected 64 items\\n\\nr2e_tests/test_1.py .....F.............................................. [ 81%]\\n............                                                             [100%]\\n\\n=================================== FAILURES ===================================\\n_______________ TestUrlDispatcher.test_add_route_with_invalid_re _______________\\n\\nself = <r2e_tests.test_1.TestUrlDispatcher testMethod=test_add_route_with_invalid_re>\\n\\n    def test_add_route_with_invalid_re(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError) as ctx:\\n            self.router.add_route('GET', r'/handler/{to:+++}', handler)\\n        s = str(ctx.exception)\\n>       self.assertTrue(s.startswith(\\n            \\\"Bad pattern '\\\\/handler\\\\/(?P<to>+++)': nothing to repeat\\\"), s)\\nE       AssertionError: False is not true : Bad pattern '/handler/(?P<to>+++)': nothing to repeat at position 17\\n\\nr2e_tests/test_1.py:402: AssertionError\\n==================================== PASSES ====================================\\n=========================== short test summary info ============================\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_invalid_path\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_invalid_method\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_not_started_with_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_root\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_simple\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_re\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_re_and_slashes\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_re_including_slashes\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_re_not_match\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_static\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_url_escaping\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_url_invalid1\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_url_invalid2\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_url_invalid3\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_url_invalid4\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_with_matchdict\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_with_name\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_with_tailing_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_any_method\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_contains\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_custom_expect_handler_dynamic\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_custom_expect_handler_plain\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_default_expect_handler\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_double_add_url_with_the_same_name\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_match_non_ascii\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_match_two_part2\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_match_unquoted_path\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_match_with_static_part\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_not_match\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_repr\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_with_trailing_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_expect_handler_non_coroutine\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_iter\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_len\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_match_second_result_in_table\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_not_allowed_repr\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_not_found_repr\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_plain_not_match\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_plain_repr\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_raise_method_not_allowed\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_raise_method_not_found\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_register_route\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_register_route_checks\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_regular_match_info\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_dynamic\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_dynamic_with_regex\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_dynamic_with_regex_spec\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_dynamic_with_regex_spec_and_trailing_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_plain\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_unknown_route_name\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_with_qs\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_abc\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_view_contains\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_view_iter\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_view_len\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_adds_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_dont_add_trailing_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_again\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_eof\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_exception\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_not_match\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_repr\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_system_route\\nFAILED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_invalid_re\\n========================= 1 failed, 63 passed in 0.22s =========================\\n\",\n    \"new_commit_res_stderr\": \"/home/gcpuser/buckets/local_repoeval_bucket/repos/aiohttp_f0d74880deec8fcd982bce639c93c5e130d41198/.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:207: PytestDeprecationWarning: The configuration option \\\"asyncio_default_fixture_loop_scope\\\" is unset.\\nThe event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: \\\"function\\\", \\\"class\\\", \\\"module\\\", \\\"package\\\", \\\"session\\\"\\n\\n  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))\\n\",\n    \"old_commit_res_code\": 1,\n    \"old_commit_res_stdout\": \"============================= test session starts ==============================\\nplatform linux -- Python 3.9.21, pytest-8.3.4, pluggy-1.5.0\\nrootdir: /home/gcpuser/buckets/local_repoeval_bucket/repos/aiohttp_f0d74880deec8fcd982bce639c93c5e130d41198\\nplugins: mock-3.14.0, asyncio-0.25.1, cov-6.0.0\\nasyncio: mode=strict, asyncio_default_fixture_loop_scope=None\\ncollected 64 items\\n\\nr2e_tests/test_1.py .....F.....................................F........ [ 81%]\\n............                                                             [100%]\\n\\n=================================== FAILURES ===================================\\n_______________ TestUrlDispatcher.test_add_route_with_invalid_re _______________\\n\\nself = <r2e_tests.test_1.TestUrlDispatcher testMethod=test_add_route_with_invalid_re>\\n\\n    def test_add_route_with_invalid_re(self):\\n        handler = self.make_handler()\\n        with self.assertRaises(ValueError) as ctx:\\n            self.router.add_route('GET', r'/handler/{to:+++}', handler)\\n        s = str(ctx.exception)\\n>       self.assertTrue(s.startswith(\\n            \\\"Bad pattern '\\\\/handler\\\\/(?P<to>+++)': nothing to repeat\\\"), s)\\nE       AssertionError: False is not true : Bad pattern '/handler/(?P<to>+++)': nothing to repeat at position 17\\n\\nr2e_tests/test_1.py:402: AssertionError\\n_________________ TestUrlDispatcher.test_register_route_checks _________________\\n\\nself = <r2e_tests.test_1.TestUrlDispatcher testMethod=test_register_route_checks>\\n\\n    def test_register_route_checks(self):\\n        self.assertRaises(\\n            AssertionError, self.router.register_route, object())\\n    \\n        handler = self.make_handler()\\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\\n        self.router.register_route(route)\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n    \\n        route = PlainRoute('GET', handler, '1bad name', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n    \\n        route = PlainRoute('GET', handler, 'return', '/handler/to/path')\\n        self.assertRaises(ValueError, self.router.register_route, route)\\n    \\n        route = PlainRoute('GET', handler, 'test.test:test',\\n                           '/handler/to/path')\\n>       self.router.register_route(route)\\n\\nr2e_tests/test_1.py:88: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \\n\\nself = <aiohttp.web_urldispatcher.UrlDispatcher object at 0x7fce689d2550>\\nroute = <PlainRoute 'test.test:test' [GET] /handler/to/path -> <function TestUrlDispatcher.make_handler.<locals>.handler at 0x7fce68a26700>\\n\\n    def register_route(self, route):\\n        assert isinstance(route, Route), 'Instance of Route class is required.'\\n    \\n        name = route.name\\n    \\n        if name is not None:\\n            if not name.isidentifier() or keyword.iskeyword(name):\\n>               raise ValueError('Incorrect route name value, '\\nE               ValueError: Incorrect route name value, Route name should be python identifier\\n\\naiohttp/web_urldispatcher.py:449: ValueError\\n==================================== PASSES ====================================\\n=========================== short test summary info ============================\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_invalid_path\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_invalid_method\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_not_started_with_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_root\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_simple\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_re\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_re_and_slashes\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_re_including_slashes\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_re_not_match\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_static\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_url_escaping\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_url_invalid1\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_url_invalid2\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_url_invalid3\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_url_invalid4\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_with_matchdict\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_with_name\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_add_with_tailing_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_any_method\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_contains\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_custom_expect_handler_dynamic\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_custom_expect_handler_plain\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_default_expect_handler\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_double_add_url_with_the_same_name\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_match_non_ascii\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_match_two_part2\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_match_unquoted_path\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_match_with_static_part\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_not_match\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_repr\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_dynamic_with_trailing_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_expect_handler_non_coroutine\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_iter\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_len\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_match_second_result_in_table\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_not_allowed_repr\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_not_found_repr\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_plain_not_match\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_plain_repr\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_raise_method_not_allowed\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_raise_method_not_found\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_register_route\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_regular_match_info\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_dynamic\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_dynamic_with_regex\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_dynamic_with_regex_spec\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_dynamic_with_regex_spec_and_trailing_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_plain\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_unknown_route_name\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_route_with_qs\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_abc\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_view_contains\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_view_iter\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_view_len\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_adds_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_dont_add_trailing_slash\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_again\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_eof\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_exception\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_not_match\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_repr\\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_system_route\\nFAILED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_invalid_re\\nFAILED r2e_tests/test_1.py::TestUrlDispatcher::test_register_route_checks - V...\\n========================= 2 failed, 62 passed in 0.15s =========================\\n\",\n    \"old_commit_res_stderr\": \"/home/gcpuser/buckets/local_repoeval_bucket/repos/aiohttp_f0d74880deec8fcd982bce639c93c5e130d41198/.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:207: PytestDeprecationWarning: The configuration option \\\"asyncio_default_fixture_loop_scope\\\" is unset.\\nThe event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: \\\"function\\\", \\\"class\\\", \\\"module\\\", \\\"package\\\", \\\"session\\\"\\n\\n  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))\\n\"\n}", "modified_files": ["HISTORY.rst", "aiohttp/web_urldispatcher.py", "tests/test_urldispatch.py"], "modified_entity_summaries": [{"ast_type_str": "ClassDef", "end_lineno": 531, "file_name": "aiohttp/web_urldispatcher.py", "name": "UrlDispatcher", "start_lineno": 385, "type": "class"}, {"ast_type_str": "ClassDef", "end_lineno": 457, "file_name": "aiohttp/web_urldispatcher.py", "name": "UrlDispatcher.register_route", "start_lineno": 442, "type": "method"}, {"ast_type_str": "ClassDef", "end_lineno": 88, "file_name": "tests/test_urldispatch.py", "name": "TestUrlDispatcher.test_register_route_checks", "start_lineno": 71, "type": "method"}, {"ast_type_str": "ClassDef", "end_lineno": 644, "file_name": "tests/test_urldispatch.py", "name": "TestUrlDispatcher", "start_lineno": 19, "type": "class"}], "relevant_files": ["aiohttp/web_urldispatcher.py"], "num_non_test_files": 2, "num_non_test_func_methods": 1, "num_non_test_lines": 22, "prompt": "You are an expert software engineer tasked with creating informative GitHub issues based on commit details and test results. These issues will be used to help junior developers and machine learning systems understand the motivation behind commits. Your goal is to create concise, clear, and realistic issues that highlight bugs without revealing solutions.\n    \nThe commit hash is f0d74880deec8fcd982bce639c93c5e130d41198. \nThe commit message is: Merge branch '0.18'\n\nConflicts:\n\tCHANGES.txt\n\taiohttp/__init__.py.\n\nThe commit patch is:\n```diff\ndiff --git a/aiohttp/web_urldispatcher.py b/aiohttp/web_urldispatcher.py\nindex 58c8c2e6..2400fddc 100644\n--- a/aiohttp/web_urldispatcher.py\n+++ b/aiohttp/web_urldispatcher.py\n@@ -389,6 +389,7 @@ class UrlDispatcher(AbstractRouter, collections.abc.Mapping):\n         r'^\\{(?P<var>[a-zA-Z][_a-zA-Z0-9]*):(?P<re>.+)\\}$')\n     GOOD = r'[^{}/]+'\n     ROUTE_RE = re.compile(r'(\\{[_a-zA-Z][^{}]*(?:\\{[^{}]*\\}[^{}]*)*\\})')\n+    NAME_SPLIT_RE = re.compile('[.:]')\n \n     METHODS = {hdrs.METH_ANY, hdrs.METH_POST,\n                hdrs.METH_GET, hdrs.METH_PUT, hdrs.METH_DELETE,\n@@ -445,15 +446,18 @@ class UrlDispatcher(AbstractRouter, collections.abc.Mapping):\n         name = route.name\n \n         if name is not None:\n-            if not name.isidentifier() or keyword.iskeyword(name):\n-                raise ValueError('Incorrect route name value, '\n-                                 'Route name should be python identifier')\n-            elif name in self._routes:\n+            parts = self.NAME_SPLIT_RE.split(name)\n+            for part in parts:\n+                if not part.isidentifier() or keyword.iskeyword(part):\n+                    raise ValueError('Incorrect route name value, '\n+                                     'Route name should be a sequence of '\n+                                     'python identifiers separated '\n+                                     'by dot or column')\n+            if name in self._routes:\n                 raise ValueError('Duplicate {!r}, '\n                                  'already handled by {!r}'\n                                  .format(name, self._routes[name]))\n-            else:\n-                self._routes[name] = route\n+            self._routes[name] = route\n         self._urls.append(route)\n \n     def add_route(self, method, path, handler,\n. \n```\n\nAdditionally, we can write the following tests to check the correctness of the commit:\n```diff\ndiff --git a/tests/test_urldispatch.py b/tests/test_urldispatch.py\nindex fd5e6848..72f74440 100644\n--- a/tests/test_urldispatch.py\n+++ b/tests/test_urldispatch.py\n@@ -83,6 +83,10 @@ class TestUrlDispatcher(unittest.TestCase):\n         route = PlainRoute('GET', handler, 'return', '/handler/to/path')\n         self.assertRaises(ValueError, self.router.register_route, route)\n \n+        route = PlainRoute('GET', handler, 'test.test:test',\n+                           '/handler/to/path')\n+        self.router.register_route(route)\n+\n     def test_add_route_root(self):\n         handler = self.make_handler()\n         self.router.add_route('GET', '/', handler)\n \n.\n```\n\n\nThese tests detect the difference between the old and new commit. Particularly,\n\nfollowing is the execution result on the old commit:\n[TRUNCATED]\n\nst_1.py::TestUrlDispatcher::test_routes_view_contains\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_view_iter\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_view_len\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_adds_slash\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_dont_add_trailing_slash\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_again\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_eof\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_exception\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_not_match\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_repr\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_system_route\nFAILED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_invalid_re\nFAILED r2e_tests/test_1.py::TestUrlDispatcher::test_register_route_checks - V...\n========================= 2 failed, 62 passed in 0.15s =========================\n\n\nfollowing is the execution result on the new commit:\n[TRUNCATED]\n\nASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_abc\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_view_contains\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_view_iter\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_routes_view_len\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_adds_slash\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_dont_add_trailing_slash\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_again\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_eof\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_handle_exception\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_not_match\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_static_repr\nPASSED r2e_tests/test_1.py::TestUrlDispatcher::test_system_route\nFAILED r2e_tests/test_1.py::TestUrlDispatcher::test_add_route_with_invalid_re\n========================= 1 failed, 63 passed in 0.22s =========================\n\n\nMore specifically, the following tests that failed in the old commit now pass in the new commit:\n- TestUrlDispatcher.test_register_route_checks\n\n\nFull test functions:\n```python\ndef test_register_route_checks(self):\n    self.assertRaises(AssertionError, self.router.register_route, object())\n    handler = self.make_handler()\n    route = PlainRoute('GET', handler, 'test', '/handler/to/path')\n    self.router.register_route(route)\n    self.assertRaises(ValueError, self.router.register_route, route)\n    route = PlainRoute('GET', handler, '1bad name', '/handler/to/path')\n    self.assertRaises(ValueError, self.router.register_route, route)\n    route = PlainRoute('GET', handler, 'return', '/handler/to/path')\n    self.assertRaises(ValueError, self.router.register_route, route)\n    route = PlainRoute('GET', handler, 'test.test:test', '/handler/to/path')\n    self.router.register_route(route)\n```\n\nIncorrect test function outputs (failing assertion / errors from before):\n```pytest\n\n================================================================================\nTestUrlDispatcher.test_register_route_checks\n================================================================================\n\nself = <r2e_tests.test_1.TestUrlDispatcher testMethod=test_register_route_checks>\n\n    def test_register_route_checks(self):\n        self.assertRaises(\n            AssertionError, self.router.register_route, object())\n    \n        handler = self.make_handler()\n        route = PlainRoute('GET', handler, 'test', '/handler/to/path')\n        self.router.register_route(route)\n        self.assertRaises(ValueError, self.router.register_route, route)\n    \n        route = PlainRoute('GET', handler, '1bad name', '/handler/to/path')\n        self.assertRaises(ValueError, self.router.register_route, route)\n    \n        route = PlainRoute('GET', handler, 'return', '/handler/to/path')\n        self.assertRaises(ValueError, self.router.register_route, route)\n    \n        route = PlainRoute('GET', handler, 'test.test:test',\n                           '/handler/to/path')\n>       self.router.register_route(route)\n\nr2e_tests/test_1.py:88: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.web_urldispatcher.UrlDispatcher object at 0x7fce689d2550>\nroute = <PlainRoute 'test.test:test' [GET] /handler/to/path -> <function TestUrlDispatcher.make_handler.<locals>.handler at 0x7fce68a26700>\n\n    def register_route(self, route):\n        assert isinstance(route, Route), 'Instance of Route class is required.'\n    \n        name = route.name\n    \n        if name is not None:\n            if not name.isidentifier() or keyword.iskeyword(name):\n>               raise ValueError('Incorrect route name value, '\nE               ValueError: Incorrect route name value, Route name should be python identifier\n\naiohttp/web_urldispatcher.py:449: ValueError```\n\n\nExample Issues:\n\nExample Issues:\n\n\n\nExample 1:\n\n[ISSUE]\n\nCode:\n\n```\nimport warnings\nimport pandas as pd\n\nwarnings.filterwarnings(\"once\", category=UserWarning)\n\nwarnings.warn(\"This is a warning\", UserWarning)\nwarnings.warn(\"This is a warning\", UserWarning)\nwarnings.warn(\"This is a second warning\", UserWarning)\nwarnings.warn(\"This is a second warning\", UserWarning)\npd.DataFrame()\nwarnings.warn(\"This is a warning\", UserWarning)\nwarnings.warn(\"This is a warning\", UserWarning)\nwarnings.warn(\"This is a second warning\", UserWarning)\nwarnings.warn(\"This is a second warning\", UserWarning)\n\n```\n\nIssue Description\nUsing filterwarnings with action 'once' should only print a warning of a specific category and text once. But calling pd.DataFrame() or other pandas functions (like pd.read_csv) makes both warnings shown twice. Deleting pd.DataFrame yields the expected behaviour.\n\nExpected Behavior\nBoth warnings (\"This is a warning\" and \"This is a second warning\") should be shown only once each.\n[/ISSUE]\n\n\nExample 2:\n\n[ISSUE]\n\nCurrently, this code will be served to the browser as text/plain but the HTML are not rendered by the browser:\n\n```\nfrom wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator\n\ndef hello_world(request):\n    request.response.content_type = \"text/html\"\n    return \"<p>Hello World</p>\"\n\nconfig = Configurator()\nconfig.add_route('hello', '/')\nconfig.add_view(hello_world, route_name='hello', renderer='string')\napp = config.make_wsgi_app()\nmake_server('', 8000, app).serve_forever()\n```\n\nI think this is unintuitive/unexpected behavior, instead when request.response.content_type is explicitly set to 'text/html', the renderer should be not change it (which it currently seems to be doing).\n\n[/ISSUE]\n\n\nExample 3:\n\n[ISSUE]\n\n\nerror is : AttributeError: 'function' object has no attribute 'copy'\n\n```\nframes = [f.copy for f in ImageSequence.Iterator(pfp)]\n\nfor i, frame in enumerate(frames):\n\tfr = frame.copy() #error here\n\tblyat.paste(fr (21,21))\n\tframes.append(blyat.copy())\n\tframes[i] = frame\nframes[0].save(\"aa.gif\", save_all=True, append_images=frames[1:], optimize=False, delay=0, loop=0, fps = 1/24)\n```\n\n[/ISSUE]\n\n\nExample 4:\n\n[ISSUE]\n\nDescription\nAccording to the documentation, the FEEDS dict accepts Path objects as keys:\n\n[...] dictionary in which every key is a feed URI (or a pathlib.Path object) [...]\n\nHowever, when using a Path object with Storage URI parameters, the FeedExporter runs into the following exception:\n\n```\n[scrapy.utils.signal] ERROR: Error caught on signal handler: <bound method FeedExporter.open_spider of <scrapy.extensions.feedexport.FeedExporter object at 0x00000240E9F21F00>>\nTraceback (most recent call last):\n  File \"...\\.venv\\lib\\site-packages\\scrapy\\utils\\defer.py\", line 348, in maybeDeferred_coro\n    result = f(*args, **kw)\n  File \"...\\.venv\\lib\\site-packages\\pydispatch\\robustapply.py\", line 55, in robustApply\n    return receiver(*arguments, **named)\n  File \"...\\.venv\\lib\\site-packages\\scrapy\\extensions\\feedexport.py\", line 467, in open_spider\n    uri=uri % uri_params,\n```\n\nSteps to Reproduce\nSet any key of the FEEDS dict to a Path object containing a %-formatted path:\n```\nFEEDS = {\n  pathlib.Path(\"./%(time)s.csv\"): {\n    \"format\": \"csv\",\n    \"store_empty\": True,\n  }\n}\n```\n\nRun any spider scrapy crawl <spider_name>.\nExpected behavior: No exception in logs and the feed file being created.\n\n[/ISSUE]\n\n\nExample 5:\n\n[ISSUE]\n\n\nWhen a callback is supplied, the future is not created and leads to a crash in the `read_until_close` method.\n\nFile \"tornado/iostream.py\", line 355, in read_until_close\n    future.add_done_callback(lambda f: f.exception())\nAttributeError: 'NoneType' object has no attribute 'add_done_callback'\n\n\n[/ISSUE]\n\n\nExample 6:\n\n[ISSUE]\nDescribe the issue:\nWhen used with large values and on large arrays, the values towards the end of the array can have very large errors in phase. \n\nReproduce the code example:\n\n```\nimport numpy as np\n\ntau = 2 * np.pi\n\ndef phase_error(x, y):\n    return (x - y + np.pi) % tau - np.pi\n\nx = np.random.uniform(-1e9, 1e9, size=64 * 1024 * 1024)\ny = np.unwrap(x)\nprint(\"Max phase error for np.unwrap: \", np.max(np.abs(phase_error(x, y))))\n```\n\nLog:\nMax phase error for np.unwrap:  0.9471197530276747\n\n[/ISSUE]\n\n\nExample 7:\n\n[ISSUE]\nTitle: Wrong result for an integral over complex exponential with a Diracdelta function\n\nI ask Sympy for the complex integral\n\n\u222b02\u03c0exp\u2061(\u2212im\u03d5)\u03b4(\u03d5\u2212\u03d50)d\u03d5,\n\nwhere m is an integer and \u03b4 is the Diracdelta distribution. For \u03d50=0, the above integral yields 0 with SymPy although it should be 1 (or 1/2 depending on the definition of the Delta function if the integral starts at the argument of the \u03b4). For 0<\u03d50<2\u03c0, the SymPy result seems correct.\n\nInterestingly, I obtain the (correct) result of 1/2 for \u03d50=2\u03c0 but zero again for \u03d50=4\u03c0. Here is my code:\n\n\n```\nimport sympy as sp\n# The SymPy version is 1.13.2\n\nphi = sp.symbols(r'\\phi', real=True)\nm = sp.symbols('m', integer=True)\n\n# This yields 0; it should be 1/2 (phi0 = 0)\nsp.integrate(sp.exp(-sp.I * m * phi) * sp.DiracDelta(phi), (phi, 0, 2 * sp.pi))\n\n# This is correct (phi0 = pi/2)\nsp.integrate(sp.exp(-sp.I * m * phi) * sp.DiracDelta(phi - sp.pi/2), (phi, 0, 2 * sp.pi))\n\n# This is correct too (phi0 = 2pi)\nsp.integrate(sp.exp(-sp.I * m * phi) * sp.DiracDelta(phi - 2 * sp.pi), (phi, 0, 2 * sp.pi))\n\n# Wrong again (phi0 = 4pi)\nsp.integrate(sp.exp(-sp.I * m * phi) * sp.DiracDelta(phi - 4 * sp.pi), (phi, 0, 2 * sp.pi))\n```\n\n[/ISSUE]\n\n\n\nAs you are trying to generate synthetic issues, you will follow these guidelines\n\n1. Keep the issue concise and informative.\n2. Describe the failing test, including the input that causes the failure, the nature of the failure, and the expected behavior. Do NOT mention test functions or files directly. Do NOT mention pytest, hypothesis, or other testing frameworks.\n3. Do not reveal the solution to the problem in the issue. Only describe the bug and the expected behavior.\n4. If there are multiple failing tests, focus on the most informative one or a subset that best describes the general nature of the failure.\n5. Describe the expected output of the failing test:\n   - For errors, describe the error message.\n   - For failing tests, mention what is supposed to happen. If the expected output is large and complex, describe the difference between the current and expected output instead of directly copying it (as human might do). Do NOT use assert statment is issue text, you are not writing test cases. \n6. Write the issue as a human would, using simple language without excessive formatting.\n7. Use concrete terms to describe the nature of the failure. Avoid vague terms like \"specific output\" or \"certain data\".\n8. INCLUDE test code to describe the bug but keep it brief and relevant. Truncate or simplify tests longer than 5-6 lines.\n9. Do not mention external files unless absolutely necessary.\n10. Format code snippets using triple backticks (```).\n\nBefore drafting the issue, analyze the following \n- Identify and quote key parts of the commit details and test results.\n- What is the main problem highlighted by the test results?\n- What is the expected behavior?\n- What is the actual behavior or error message?\n- How can you describe the issue concisely while providing enough information for developers to understand and investigate?\n- Envision yourself as a human stumbling upon this bug. Provide the bug report from that perspective. Focus on clarity and naturalness in your writing.\n\nAfter your analysis, draft the GitHub issue enclosed in [ISSUE] [/ISSUE] tags. The issue should include:\n1. A clear and concise title (choose the best one from your brainstormed list)\n2. A description of the problem \n    2.1 ensure adding a detailed example buggy code with sufficient explaintation\n    2.2 ensure the example buggy code is natural, it should resemble a unittest, it should not have assertions \n    2.3 add details about the test scaffolding if necessary\n3. Expected behavior\n4. Actual behavior or error message\n\nIMPORTANT: Strictly follow the above guidelines and use the provided test execution results to write the issue. Draw inspiration from the examples provided and make sure to provide good concise and natural issues. Remember to write the issue as a human would, focusing on clarity and relevance. For naturalness, envi\n\n\n", "problem_statement": "[ISSUE]\n\n**Title:** Unable to Register Route with Names Containing Both Dots and Colons\n\n**Description:**\nAfter merging branch '0.18', attempting to register a route with a name that includes both dots (`.`) and colons (`:`) results in a `ValueError`. The recent changes were intended to allow route names to be a sequence of Python identifiers separated by dots or colons, but this combination is still causing issues.\n\n**Example Code:**\n```python\nfrom aiohttp.web import UrlDispatcher, PlainRoute\n\ndef handler(request):\n    return 'Hello'\n\nrouter = UrlDispatcher()\n\n# Attempting to register a route with both dots and colons in the name\nroute = PlainRoute('GET', handler, 'test.test:test', '/handler/to/path')\nrouter.register_route(route)\n```\n\n**Expected Behavior:**\nRegistering a route with a name like `'test.test:test'` should succeed without errors, as the name follows the updated rules allowing multiple identifiers separated by dots or colons.\n\n**Actual Behavior:**\nA `ValueError` is raised with the message:\n```\nValueError: Incorrect route name value, Route name should be a sequence of python identifiers separated by dot or column\n```\nThis prevents the registration of route names that include both dots and colons, contrary to the intended flexibility introduced in the recent commit.\n\n[/ISSUE]", "expected_output_json": "{\n    \"TestUrlDispatcher.test_add_invalid_path\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_route_invalid_method\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_route_not_started_with_slash\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_route_root\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_route_simple\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_route_with_re\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_route_with_re_and_slashes\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_route_with_re_including_slashes\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_route_with_re_not_match\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_static\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_url_escaping\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_url_invalid1\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_url_invalid2\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_url_invalid3\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_url_invalid4\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_with_matchdict\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_with_name\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_with_tailing_slash\": \"PASSED\",\n    \"TestUrlDispatcher.test_any_method\": \"PASSED\",\n    \"TestUrlDispatcher.test_contains\": \"PASSED\",\n    \"TestUrlDispatcher.test_custom_expect_handler_dynamic\": \"PASSED\",\n    \"TestUrlDispatcher.test_custom_expect_handler_plain\": \"PASSED\",\n    \"TestUrlDispatcher.test_default_expect_handler\": \"PASSED\",\n    \"TestUrlDispatcher.test_double_add_url_with_the_same_name\": \"PASSED\",\n    \"TestUrlDispatcher.test_dynamic_match_non_ascii\": \"PASSED\",\n    \"TestUrlDispatcher.test_dynamic_match_two_part2\": \"PASSED\",\n    \"TestUrlDispatcher.test_dynamic_match_unquoted_path\": \"PASSED\",\n    \"TestUrlDispatcher.test_dynamic_match_with_static_part\": \"PASSED\",\n    \"TestUrlDispatcher.test_dynamic_not_match\": \"PASSED\",\n    \"TestUrlDispatcher.test_dynamic_repr\": \"PASSED\",\n    \"TestUrlDispatcher.test_dynamic_with_trailing_slash\": \"PASSED\",\n    \"TestUrlDispatcher.test_expect_handler_non_coroutine\": \"PASSED\",\n    \"TestUrlDispatcher.test_iter\": \"PASSED\",\n    \"TestUrlDispatcher.test_len\": \"PASSED\",\n    \"TestUrlDispatcher.test_match_second_result_in_table\": \"PASSED\",\n    \"TestUrlDispatcher.test_not_allowed_repr\": \"PASSED\",\n    \"TestUrlDispatcher.test_not_found_repr\": \"PASSED\",\n    \"TestUrlDispatcher.test_plain_not_match\": \"PASSED\",\n    \"TestUrlDispatcher.test_plain_repr\": \"PASSED\",\n    \"TestUrlDispatcher.test_raise_method_not_allowed\": \"PASSED\",\n    \"TestUrlDispatcher.test_raise_method_not_found\": \"PASSED\",\n    \"TestUrlDispatcher.test_register_route\": \"PASSED\",\n    \"TestUrlDispatcher.test_register_route_checks\": \"PASSED\",\n    \"TestUrlDispatcher.test_regular_match_info\": \"PASSED\",\n    \"TestUrlDispatcher.test_route_dynamic\": \"PASSED\",\n    \"TestUrlDispatcher.test_route_dynamic_with_regex\": \"PASSED\",\n    \"TestUrlDispatcher.test_route_dynamic_with_regex_spec\": \"PASSED\",\n    \"TestUrlDispatcher.test_route_dynamic_with_regex_spec_and_trailing_slash\": \"PASSED\",\n    \"TestUrlDispatcher.test_route_plain\": \"PASSED\",\n    \"TestUrlDispatcher.test_route_unknown_route_name\": \"PASSED\",\n    \"TestUrlDispatcher.test_route_with_qs\": \"PASSED\",\n    \"TestUrlDispatcher.test_routes_abc\": \"PASSED\",\n    \"TestUrlDispatcher.test_routes_view_contains\": \"PASSED\",\n    \"TestUrlDispatcher.test_routes_view_iter\": \"PASSED\",\n    \"TestUrlDispatcher.test_routes_view_len\": \"PASSED\",\n    \"TestUrlDispatcher.test_static_adds_slash\": \"PASSED\",\n    \"TestUrlDispatcher.test_static_dont_add_trailing_slash\": \"PASSED\",\n    \"TestUrlDispatcher.test_static_handle_again\": \"PASSED\",\n    \"TestUrlDispatcher.test_static_handle_eof\": \"PASSED\",\n    \"TestUrlDispatcher.test_static_handle_exception\": \"PASSED\",\n    \"TestUrlDispatcher.test_static_not_match\": \"PASSED\",\n    \"TestUrlDispatcher.test_static_repr\": \"PASSED\",\n    \"TestUrlDispatcher.test_system_route\": \"PASSED\",\n    \"TestUrlDispatcher.test_add_route_with_invalid_re\": \"FAILED\"\n}"}