#!/usr/bin/env python3
"""
Utility script to analyze attempt log files generated by r2egym_buggen_w_agentic_ps.py

Usage:
    python analyze_attempts.py <path_to_attempts.jsonl>
"""

import json
import sys
from pathlib import Path
from collections import defaultdict


def analyze_attempt_log(log_file: str | Path):
    """
    Analyze an attempt log file and print detailed statistics.

    Args:
        log_file: Path to the .jsonl attempt log file
    """
    log_file = Path(log_file)

    if not log_file.exists():
        print(f"Error: Log file not found: {log_file}")
        sys.exit(1)

    print(f"\nAnalyzing attempt log: {log_file}")
    print("=" * 80)

    # Read all attempts
    attempts = []
    with open(log_file, "r") as f:
        for line in f:
            attempts.append(json.loads(line))

    if not attempts:
        print("No attempts found in log file.")
        return

    # Overall statistics
    total_attempts = len(attempts)
    success_count = sum(1 for a in attempts if a["status"] == "success")
    failed_count = sum(1 for a in attempts if a["status"] == "failed")

    print(f"\nOVERALL STATISTICS")
    print("-" * 80)
    print(f"Total attempts: {total_attempts}")
    print(f"Successful: {success_count} ({success_count/total_attempts*100:.1f}%)")
    print(f"Failed: {failed_count} ({failed_count/total_attempts*100:.1f}%)")

    # Failure analysis
    if failed_count > 0:
        print(f"\nFAILURE ANALYSIS")
        print("-" * 80)

        error_counts = defaultdict(int)
        for entry in attempts:
            if entry["status"] == "failed" and entry["error_reason"]:
                error_counts[entry["error_reason"]] += 1

        print(f"Failures by reason:")
        for reason, count in sorted(error_counts.items(), key=lambda x: x[1], reverse=True):
            percentage = count / failed_count * 100
            print(f"  {count:4d} ({percentage:5.1f}%) - {reason}")

    # Attempt distribution
    print(f"\nATTEMPT DISTRIBUTION")
    print("-" * 80)

    attempt_counts = defaultdict(int)
    for entry in attempts:
        attempt_counts[entry["attempt"]] += 1

    for attempt_num in sorted(attempt_counts.keys()):
        count = attempt_counts[attempt_num]
        print(f"  Attempt {attempt_num}: {count} jobs")

    # Per-image success rate
    print(f"\nPER-IMAGE ANALYSIS")
    print("-" * 80)

    image_stats = defaultdict(lambda: {"success": 0, "failed": 0, "total": 0})
    for entry in attempts:
        image = entry["image_name"]
        image_stats[image]["total"] += 1
        if entry["status"] == "success":
            image_stats[image]["success"] += 1
        else:
            image_stats[image]["failed"] += 1

    # Sort by total attempts (descending)
    sorted_images = sorted(image_stats.items(), key=lambda x: x[1]["total"], reverse=True)

    print(f"Top 10 images by number of attempts:")
    for i, (image, stats) in enumerate(sorted_images[:10], 1):
        success_rate = stats["success"] / stats["total"] * 100 if stats["total"] > 0 else 0
        print(f"  {i:2d}. {image}")
        print(f"      Total: {stats['total']}, Success: {stats['success']}, Failed: {stats['failed']} ({success_rate:.1f}% success)")

    # Unique instances
    unique_instances = set(a["instance_id"] for a in attempts if a["status"] == "success")
    print(f"\nUNIQUE SUCCESSFUL INSTANCES")
    print("-" * 80)
    print(f"Total unique successful instances: {len(unique_instances)}")

    print("\n" + "=" * 80)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python analyze_attempts.py <path_to_attempts.jsonl>")
        sys.exit(1)

    analyze_attempt_log(sys.argv[1])
